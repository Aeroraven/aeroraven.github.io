(()=>{"use strict";class t{static log(t){}}class e{constructor(t){this.gl=t}loadShader(t,e){const n=this.gl.createShader(t);return this.gl.shaderSource(n,e),this.gl.compileShader(n),this.gl.getShaderParameter(n,this.gl.COMPILE_STATUS)?n:(console.log("[CGProject] Failed To Compile Shader"),console.log(this.gl.getShaderInfoLog(n)),this.gl.deleteShader(n),null)}initShaderProgram(e,n){t.log("Compiling Vertex Shader");const r=this.loadShader(this.gl.VERTEX_SHADER,e);t.log("Compiling Fragment Shader");const i=this.loadShader(this.gl.FRAGMENT_SHADER,n),a=this.gl.createProgram();return this.gl.attachShader(a,r),this.gl.attachShader(a,i),this.gl.linkProgram(a),this.gl.getProgramParameter(a,this.gl.LINK_STATUS)?(console.log("[CGProject] Shader created"),a):(console.log("[CGProject] Failed to initialize the shader"),console.log(this.gl.getProgramInfoLog(a)),null)}}class n{constructor(t){this.gl=t,this.vertexShader="",this.fragmentShader=""}getVertexShader(){}getFragmentShader(){}getShaderProgramEx(t,n){let r=new e(this.gl);return console.log(t),console.log(n),r.initShaderProgram(t,n)}}class r{constructor(t,e,n){this.pt=t,this.cl=e,this.tx=null==n?[0,0]:n}}var i=1e-6,a="undefined"!=typeof Float32Array?Float32Array:Array;function s(){var t=new a(3);return a!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)}),s();class o{constructor(t,e,n){this.x=t,this.y=e,this.z=n}add(t){return new o(this.x+t.x,this.y+t.y,this.z+t.z)}dot(t){return new o(this.x*t.x,this.y*t.y,this.z*t.z)}cross(t){return new o(y*t.z-z*t.y,-x*t.z+z*t.x,x*t.y-y*t.x)}neg(){return new o(-this.x,-this.y,-this.z)}set(t,e,n){this.x=t,this.y=e,this.z=n}getGLMatVec3(){let t=s();return t[0]=this.x,t[1]=this.y,t[2]=this.z,t}dist(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}norm(){let t=this.dist();return new o(this.x/t,this.y/t,this.z/t)}magnify(t){return new o(this.x*t,this.y*t,this.z*t)}}class l{constructor(){this.light=new o(1,1,1)}setLight(t){this.light=t}}class h{constructor(t){this.gl=t,this.fb=t.createFramebuffer(),this.depBuf=t.createRenderbuffer(),this.depth=!1}bindTexture(t,e,n){let r=this.gl;r.bindFramebuffer(r.FRAMEBUFFER,this.fb),r.bindTexture(r.TEXTURE_2D,e.getTexture()),r.framebufferTexture2D(r.FRAMEBUFFER,t,r.TEXTURE_2D,e.getTexture(),e,0),this.depth=n,n&&(r.bindRenderbuffer(r.RENDERBUFFER,this.depBuf),r.renderbufferStorage(r.RENDERBUFFER,r.DEPTH_COMPONENT16,e.getW(),e.getH()),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.RENDERBUFFER,this.depBuf)),r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null)}bindTexturePingPong(t,e,n){let r=this.gl;r.bindFramebuffer(r.FRAMEBUFFER,this.fb),r.bindTexture(r.TEXTURE_2D,e.getTexture()),r.framebufferTexture2D(r.FRAMEBUFFER,t,r.TEXTURE_2D,n.getTexture(),0),r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null)}start(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,this.fb)}end(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null)}}function c(){var t=new a(4);return a!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}c();class u{constructor(t,e,n,r){this.r=t,this.g=e,this.b=n,this.a=r}getGLMatVec4(){let t=c();return t[0]=this.r,t[1]=this.g,t[2]=this.b,t[3]=this.a,t}}function f(){var t=new a(16);return a!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}var d=function(t,e,n){var r=e[0],i=e[1],a=e[2],s=e[3],o=e[4],l=e[5],h=e[6],c=e[7],u=e[8],f=e[9],d=e[10],g=e[11],m=e[12],p=e[13],v=e[14],x=e[15],R=n[0],y=n[1],T=n[2],b=n[3];return t[0]=R*r+y*o+T*u+b*m,t[1]=R*i+y*l+T*f+b*p,t[2]=R*a+y*h+T*d+b*v,t[3]=R*s+y*c+T*g+b*x,R=n[4],y=n[5],T=n[6],b=n[7],t[4]=R*r+y*o+T*u+b*m,t[5]=R*i+y*l+T*f+b*p,t[6]=R*a+y*h+T*d+b*v,t[7]=R*s+y*c+T*g+b*x,R=n[8],y=n[9],T=n[10],b=n[11],t[8]=R*r+y*o+T*u+b*m,t[9]=R*i+y*l+T*f+b*p,t[10]=R*a+y*h+T*d+b*v,t[11]=R*s+y*c+T*g+b*x,R=n[12],y=n[13],T=n[14],b=n[15],t[12]=R*r+y*o+T*u+b*m,t[13]=R*i+y*l+T*f+b*p,t[14]=R*a+y*h+T*d+b*v,t[15]=R*s+y*c+T*g+b*x,t};class g{constructor(){this.projectionMat=f(),this.modelViewMat=f(),this.camPositon=new o(0,0,0),this.camCenter=new o(0,0,0),this.camUp=new o(0,0,0),window.r=this.modelViewMat}setPerspective(t,e,n,r){!function(t,e,n,r,i){var a,s=1/Math.tan(e/2);t[0]=s/n,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=s,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=i&&i!==1/0?(a=1/(r-i),t[10]=(i+r)*a,t[14]=2*i*r*a):(t[10]=-1,t[14]=-2*r)}(this.projectionMat,t,e,n,r)}setOrtho(t,e,n,r,i,a){!function(t,e,n,r,i,a,s){var o=1/(e-n),l=1/(r-i),h=1/(a-s);t[0]=-2*o,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*l,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*h,t[11]=0,t[12]=(e+n)*o,t[13]=(i+r)*l,t[14]=(s+a)*h,t[15]=1}(this.projectionMat,t,e,r,n,i,a)}setCamPosition(t){this.camPositon=t}setCamCenter(t){this.camCenter=t}setCamUp(t){this.camUp=t}translate(t){this.camCenter.add(t),this.camPositon.add(t)}generate(){var t,e,n,r,a,s,o,l,h,c,u,f,d,g,m,p,v,x,R,y,T,b,C;t=this.modelViewMat,e=this.camPositon.getGLMatVec3(),n=this.camCenter.getGLMatVec3(),r=this.camUp.getGLMatVec3(),m=e[0],p=e[1],v=e[2],x=r[0],R=r[1],y=r[2],T=n[0],b=n[1],C=n[2],Math.abs(m-T)<i&&Math.abs(p-b)<i&&Math.abs(v-C)<i?function(t){t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1}(t):(u=m-T,f=p-b,d=v-C,a=R*(d*=g=1/Math.hypot(u,f,d))-y*(f*=g),s=y*(u*=g)-x*d,o=x*f-R*u,(g=Math.hypot(a,s,o))?(a*=g=1/g,s*=g,o*=g):(a=0,s=0,o=0),l=f*o-d*s,h=d*a-u*o,c=u*s-f*a,(g=Math.hypot(l,h,c))?(l*=g=1/g,h*=g,c*=g):(l=0,h=0,c=0),t[0]=a,t[1]=l,t[2]=u,t[3]=0,t[4]=s,t[5]=h,t[6]=f,t[7]=0,t[8]=o,t[9]=c,t[10]=d,t[11]=0,t[12]=-(a*m+s*p+o*v),t[13]=-(l*m+h*p+c*v),t[14]=-(u*m+f*p+d*v),t[15]=1),window.x=this.modelViewMat,window.w=this.camPositon}getMatrix(){return this.generate(),{proj:this.projectionMat,view:this.modelViewMat}}}class m{constructor(t,e,n,r){this.w=e,this.h=n,this.gl=t,this.tex=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this.tex),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,this.w,this.h,0,t.RGBA,t.UNSIGNED_BYTE,r),t.bindTexture(t.TEXTURE_2D,null)}disableMips(){let t=this.gl;t.bindTexture(t.TEXTURE_2D,this.tex),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,!0),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.generateMipmap(t.TEXTURE_2D),t.bindTexture(t.TEXTURE_2D,null)}getTexture(){return this.tex}start(){this.gl.bindTexture(this.gl.TEXTURE_2D,this.tex)}end(){this.gl.bindTexture(this.gl.TEXTURE_2D,null)}getW(){return this.w}getH(){return this.h}updateTexture(t){window.i=t;let e=this.gl;e.bindTexture(e.TEXTURE_2D,this.tex),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,t),e.bindTexture(e.TEXTURE_2D,null)}loadImageAsync(t){const e=new Image,n=this;e.onload=function(){n.updateTexture(e)},e.src=t}}class p{constructor(){this.hashmap={}}insert(t,e,n,r=null){this.hashmap[t]={},this.hashmap[t].type=n,this.hashmap[t].initValue=e,this.hashmap[t].name=t,this.hashmap[t].ext=r}clear(){this.hashmap={}}getSourceFragment(){let t="";for(let e in this.hashmap){let n=this.hashmap[e];t+="uniform ",t+=n.type,t+=n.name,t+=";\n"}return t}bindShaderVarible(e,n){for(let r in this.hashmap){let i=this.hashmap[r],a=e.getUniformLocation(n,i.name);t.log("Binding uniform variable:"+r+"( "+i.type+")"),t.log(i.initValue),i.type==p.MAT4&&e.uniformMatrix4fv(a,!1,i.initValue),i.type==p.VEC3&&e.uniform3fv(a,i.initValue),i.type==p.VEC4&&e.uniform4fv(a,i.initValue),i.type==p.VEC2&&e.uniform2fv(a,i.initValue),i.type==p.INT&&e.uniform1i(a,i.initValue),i.type==p.FLOAT&&e.uniform1f(a,i.initValue),i.type==p.SAMPLER2D&&(0==i.initValue&&e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,i.ext),e.uniform1i(a,i.initValue))}}}p.MAT4="mat4 ",p.VEC3="vec3 ",p.VEC4="vec4 ",p.VEC2="vec2 ",p.INT="int ",p.BOOL="bool ",p.FLOAT="float ",p.SAMPLER2D="sampler2D ";class v{constructor(t,e){this.cl=new u(1,1,1,1),this.name="RTAmbientLight"+e,null!=t&&(this.cl=t)}updateMap(t){t.insert(this.name+"_CL",this.cl.getGLMatVec4(),p.VEC4)}genCode(){return"\n        ambient = vec4("+this.name+"_CL);\n        "}}class R{constructor(t,e){this.cl=new u(1,1,1,1),this.name="RTSkyLight"+e,null!=t&&(this.cl=t)}updateMap(t){t.insert(this.name+"_CL",this.cl.getGLMatVec4(),p.VEC4)}genCode(){return"\n        skylight = vec4("+this.name+"_CL);\n        "}}class T{constructor(t){this.cam=new g,this.cam.setPerspective(55*Math.PI/180,t.canvas.height/t.canvas.width,.1,100),this.cam.setCamPosition(new o(0,0,-6)),this.cam.setCamUp(new o(0,1,0)),this.cam.setCamCenter(new o(0,0,0))}getCameraMatrix(){return d(this.cam.getMatrix().proj,this.cam.getMatrix().view)}getEye(){return this.cam.camPositon}getRay(t,e,n=0){let r=new o(t,e,n),i=f();var a,s,l,h;a=i,s=r.x,l=r.y,h=r.z,a[0]=s,a[1]=0,a[2]=0,a[3]=0,a[4]=l,a[5]=0,a[6]=0,a[7]=0,a[8]=h,a[9]=0,a[10]=0,a[11]=0,a[12]=1,a[13]=0,a[14]=0,a[15]=0;let c=f();return d(c,c,i),new o(c[0],c[4],c[8]).add(this.getEye().neg()).getGLMatVec3()}prepareShaderMap(t){t.insert("raylt",this.getRay(-1,1),p.VEC3),t.insert("raylb",this.getRay(-1,-1),p.VEC3),t.insert("rayrb",this.getRay(1,-1),p.VEC3),t.insert("rayrt",this.getRay(1,1),p.VEC3),t.insert("eye",this.getEye().getGLMatVec3(),p.VEC3)}}class b extends n{constructor(t){super(t),this.gl=t,this.vertexShader="  ",this.fragmentShader="  "}getFragShader(t){return this.fragmentShader=t.genFragmentShader(),this.fragmentShader}getVertexShader(){return this.vertexShader="#version 300 es\n        in vec4 aVertexPosition;\n        in vec4 aVertexColor;\n        in vec2 aVertexTex;\n\n        uniform mat4 uModelViewMatrix;\n        uniform mat4 uProjectionMatrix;\n        uniform vec3 raylb;\n        uniform vec3 raylt;\n        uniform vec3 rayrb;\n        uniform vec3 rayrt;\n\n        out highp vec3 ray;\n        out highp vec4 color;\n        out highp vec2 tex;\n        void main() {\n            float yp = aVertexPosition.y*0.5+0.5;\n            gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\n            ray = mix(mix(raylb,raylt,yp),mix(rayrb,rayrt,yp),aVertexPosition.x*0.5+0.5);\n            color = aVertexColor;\n            tex = aVertexTex;\n        }\n        ",this.vertexShader}getFragShaderTest(t){return this.fragmentShader="precision highp float;\n            varying highp vec3 ray;\n            void main(){\n                gl_FragColor = vec4(color);\n            }\n        ",this.fragmentShader}getShaderProgram(t){return this.getShaderProgramEx(this.getVertexShader(),this.getFragShader(t))}getLocationsInfo(t){return this.getShaderProgram(t)}}class C{static structDef_Ray(){return"\n            struct sRay{\n                vec3 origin;\n                vec3 direction;\n                vec3 color;\n            };\n        "}static structDef_Photon(){return"\n            struct sPhoton{\n                vec3 position;\n                vec3 direction;\n                vec3 color;\n            };\n\n            sPhoton photons[1200];\n\n            int phItr = 0;\n            int pMaxIndex = 1200;\n        "}static structDef_Plane(){return"\n            struct sPlane{\n                vec3 x,y,z;\n                vec4 emissionColor;\n                vec4 materialColor;\n                \n            };\n        "}static structDef_Sphere(){return"\n            struct sSphere{\n                vec3 c;\n                float r;\n                vec4 emissionColor;\n                vec4 materialColor;\n                \n            };\n        "}static structDef_RayCollisionResult(){return"\n            struct sRayCollisionResult{\n                vec3 colvex;\n                vec3 colnorm;\n                bool collided;\n                vec4 emissionColor;\n                vec4 materialColor;\n                int hitType;\n            };\n        "}static structDefConcat(){let t=[C.structDef_Plane,C.structDef_Ray,C.structDef_Photon,C.structDef_Sphere,C.structDef_RayCollisionResult],e="";for(let n=0;n<t.length;n++)e+=t[n]();return e}static funcDef_RayPoint(){return"\n            vec3 fRayPoint(sRay ray,float t){\n                return  ray.origin+ t * ray.direction;\n            }\n        "}static funcDef_PlaneNorm(){return"\n            vec3 fPlaneNorm(sPlane p){\n                return cross(p.y-p.x,p.z-p.y);\n            }\n        "}static funcDef_RayPlaneIntersection(){return"\n            float fRayPlaneIntersection(sRay r,sPlane p){\n                vec3 n = fPlaneNorm(p);\n                vec3 di = r.direction;\n                vec3 or = r.origin;\n                vec3 a = p.y;\n                float rd = dot(n,di);\n                float rn = n.x*(a.x-or.x)+n.y*(a.y-or.y)+n.z*(a.z-or.z);\n                return rn/rd;\n            }\n        "}static funcDef_RaySphereIntersection(){return"\n            float fRaySphereIntersection(sRay r,sSphere s){\n                vec3 p = r.origin-s.c;\n                float a = dot(r.direction,r.direction);\n                float b = 2.0*(dot(r.direction,p));\n                float delta = b*b-4.0*a*(dot(p,p)-s.r*s.r);\n                if(delta<1e-10){\n                    return -1.0;\n                }else{\n                    float sdelta = sqrt(delta);\n                    float t1 = (-b+sdelta)/(2.0*a);\n                    float t2 = (-b-sdelta)/(2.0*a);\n                    if(t1>0.0&&t2>0.0){\n                        if(t1>t2){\n                            return t2;\n                        }\n                        return t1;\n                    }\n                    if(t1>0.0&&t2<0.0){\n                        return t1;\n                    }\n                    return t2;\n                }\n                return 0.0;\n            }\n        "}static funcDef_InsidePlane(){return"\n            bool fInsidePlane(sPlane p,vec3 v){\n                vec3 v1 = p.x - v;\n                vec3 v2 = p.y - v;\n                vec3 v3 = p.z - v;\n                float s1 = length(cross(v1,v2));\n                float s2 = length(cross(v2,v3));\n                float s3 = length(cross(v3,v1));\n                float s0 = length(cross(p.y-p.x,p.z-p.x));\n                if(abs(abs(s0)-abs(s1)-abs(s2)-abs(s3))<1e-5){\n                    return true;\n                }\n                return false;\n            }\n        "}static funcDef_SpecularReflection(){return"\n            sRay fSpecularReflection(sRay inr,vec3 p,vec3 n){\n                if(dot(inr.direction,n)>0.0){\n                    n = -n;\n                }\n                vec3 ox = inr.direction/dot(inr.direction,n)+2.0*n;\n                sRay ret = sRay(p,ox/length(ox),inr.color);\n                return ret;\n            }\n        "}static funcDef_RandNoiseV3(){return"\n            float rng()\n            {\n                seeds += uvec2(1);\n                uvec2 q = 1103515245U * ( (seeds >> 1U) ^ (seeds.yx) );\n                uint  n = 1103515245U * ( (q.x) ^ (q.y >> 3U) );\n                return float(n) * (1.0 / float(0xffffffffU));\n            }\n            vec3 uniformlyRandomDirectionNew() {\n                float up = rng() * 2.0 - 1.0; \n                float over = sqrt( max(0.0, 1.0 - up * up) );\n                float around = rng() * 6.28318530717;\n                return normalize(vec3(cos(around) * over, up, sin(around) * over));\t\n            }\n        "}static funcDef_DiffuseReflection(){return"\n            sRay fDiffuseReflection(sRay inr,vec3 p,vec3 norm,float attenCoe){\n                vec3 n = norm;\n                n = n / length(n);\n                if(dot(inr.direction,norm)>0.0){\n                    n = -n;\n                }\n                vec3 o = uniformlyRandomDirectionNew();\n                if(dot(o,n)<0.0){\n                    o = -o;\n                }\n                sRay rt = sRay(p,o,inr.color*attenCoe);\n                return rt;\n            }\n        "}static funcDef_RayCollision(t=""){return"\n            sRayCollisionResult fRayCollision(sRay r){\n                float t = 1e30;\n                vec3 norm = vec3(0.0,0.0,0.0);\n                vec4 emicolor = vec4(1.0,1.0,1.0,1.0);\n                vec4 matcolor = vec4(0.0,0.0,0.0,1.0);\n                bool collided = false;\n                float tc=1e30;\n                int hitType = 0;\n                bool colc = false;\n                "+t+"\n                vec3 colp = fRayPoint(r,t);\n                sRayCollisionResult ret = sRayCollisionResult(colp,norm,collided,emicolor,matcolor,hitType);\n                return ret;\n            }\n        "}static funcDef_GammaCorrection(){return"\n            vec4 fGammaCorrection(vec4 col,float g){\n                return vec4(pow(col.x,g),pow(col.y,g),pow(col.z,g),pow(col.w,g));\n            }\n        "}static funcDef_Raytracing(t){return"\n            vec4 fRaytracing(sRay r){\n                sRay rp = r;\n                vec4 accColor = vec4(0.0,0.0,0.0,1.0);\n                vec4 accMaterial = vec4(1.0,1.0,1.0,1.0);\n                vec4 ambient = vec4(0.0,0.0,0.0,1.0);\n                vec4 skylight = vec4(0.0,0.0,0.0,1.0);\n                "+t+"\n                for(int i=1;i < 30;i+=1){\n                    rp.direction = rp.direction / length(rp.direction);\n                    sRayCollisionResult hit = fRayCollision(rp);\n                    if(hit.collided == false){\n                        accColor = accColor + accMaterial * skylight; \n                        break;\n                    }\n                    accMaterial = accMaterial * hit.materialColor;\n                    if(hit.hitType==1){\n                        rp = fDiffuseReflection(rp,hit.colvex,hit.colnorm);\n                        float lambert = abs(dot(hit.colnorm,rp.direction))/length(hit.colnorm)/length(rp.direction);\n                        accColor = accColor + accMaterial * (hit.emissionColor+ambient) * lambert;\n                    }else if(hit.hitType==2){\n                        accColor = accColor + accMaterial * (hit.emissionColor+ambient);\n                        rp = fSpecularReflection(rp,hit.colvex,hit.colnorm);\n                    }\n                    if(i>5&&accMaterial.x<1e-2&&accMaterial.y<1e-2&&accMaterial.z<1e-2){\n                        break;\n                    }\n                }\n                return accColor;\n            }\n        "}static funcDef_PhotonMapGenerate(){return"\n            void fPhotonMapGenerate(){\n                int nEmittedPhotons = 30;\n                float initCoe = 12.56;\n                float reflectRate = 0.5;\n                float N = 1.0;\n                float attenCoe = reflectRate/N;\n                int maxLoop = 60;\n                float reflectRadio = 0.05;\n                for(int i=0 ; i<nEmittedPhotons;i++){\n                    vec3 random = uniformlyRandomDirectionNew();\n                    if (random.y>0.0){\n                        random = -random;\n                    }\n                    sRay r = sRay(vec3(0.6,0.5,7),random,vec3(1.0,1.0,1.0));\n                    for(int j=0 ; j<maxLoop ; j++){\n                        sRayCollisionResult hit = fRayCollision(r);\n                        if(hit.collided == false){ \n                            break;\n                        }\n                        if(hit.hitType==1){\n                            vec3 oldColor = r.color;\n                            r = fDiffuseReflection(r,hit.colvex,hit.colnorm,attenCoe); \n                            r.color = r.color*hit.materialColor.xyz;\n                            photons[phItr] = sPhoton(hit.colvex,r.direction,r.color);\n                            phItr++;\n                            if(phItr==pMaxIndex){\n                                break;\n                            }\n                            // if(rng()<reflectRadio){\n                            //     break;\n                            // }\n                        }\n                        else if(hit.hitType==2){\n                            r = fSpecularReflection(r,hit.colvex,hit.colnorm);\n                        }\n                    }\n                    \n                }\n               \n            }\n        "}static funcDef_Distance(){return"\n            float fDistance(vec3 a, vec3 b){\n                return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n            }\n        "}static funcDef_Main(){return"\n            void main(){\n                seeds = uvec2(uint(uTime),uint(uTime));\n                fPhotonMapGenerate();\n                const int loops = 10;\n                vec3 nray = ray / length(ray);\n                bool isDiffuse = false;\n                sRay r = sRay(eye,nray,vec3(0,0,0));\n                vec3 collidPos = vec3(0,0,0);\n                vec3 collidDir = vec3(0,0,0);\n                for(int i=0 ; i<loops ; i++){\n                    sRayCollisionResult hit = fRayCollision(r);\n                    if(hit.collided==false){\n                        fragmentColor = vec4(0,0.5,0,1.0);\n                        return;\n                    }\n                    if(hit.hitType==1){\n                        isDiffuse = true;\n                        collidPos = hit.colvex;\n                        collidDir = r.direction;\n                        break;\n                    }\n                    else if(hit.hitType==2){\n                        r = fSpecularReflection(r,hit.colvex,hit.colnorm);\n                    }\n                }\n                if(isDiffuse){\n                    int nMin = 50;\n                    int index[50];\n                    for(int j=0;j<nMin;j++){\n                        index[j] = -1;\n                    }\n                    float maxMinDis = -999999.0;\n\n                    vec4 accColor = vec4(0.0,0.0,0.0,1.0);\n\n                    for(int j=0;j<nMin;j++){\n\n                        float minDis = 999999.0;\n                        int minIndex = -1;\n                        vec3 pos = vec3(0,0,0);\n                        float dis = 0.0;\n                        bool flag = true;\n                        for(int i=0;i<phItr;i++){\n                            dis = length(photons[i].position-collidPos);\n                            if(dis<minDis){\n                                for(int k=0;k<j;k++){\n                                    if(index[k]==i){\n                                        flag = false;\n                                    }\n                                }\n                                if(flag){\n                                    minDis = dis;\n                                    minIndex = i;\n                                }\n                            }\n                        }\n                        if(minDis>maxMinDis){\n                            maxMinDis = minDis;\n                        }\n\n                        float flux = dot(normalize(photons[minIndex].direction),collidDir);\n\n                        accColor = accColor + vec4(max(flux,0.0)*photons[minIndex].color,1.0);\n\n                    }\n\n                    accColor = accColor/(maxMinDis*maxMinDis*3.14*float(phItr));\n\n                    vec4 textc = texture(uTexture, vec2(1.0-tex.s,tex.t));\n                    vec4 fragc = accColor;\n                    // if(accColor.x<0.0 || accColor.y<0.0 || accColor.z<0.0 ){\n                    //     fragmentColor = vec4(1.0,0.0,0.0,1.0);\n                    //     return;\n                    // }\n                    fragmentColor = (textc*float(uSamples) + fragc)/(float(uSamples)+1.0);\n                    fragmentColor.x = min(1.0,fragmentColor.x);\n                    fragmentColor.y = min(1.0,fragmentColor.y);\n                    fragmentColor.z = min(1.0,fragmentColor.z);\n                    return;\n                }\n\n                \n\n                vec4 textc = texture(uTexture, vec2(1.0-tex.s,tex.t));\n                fragmentColor = (textc*float(uSamples))/(float(uSamples));\n                return;\n                // fragmentColor = vec4(1.0,0.0,0.0,1.0);\n            }\n        "}static funcDefConcat(t){let e=[[C.funcDef_GammaCorrection,null],[C.funcDef_RandNoiseV3,null],[C.funcDef_DiffuseReflection,null],[C.funcDef_InsidePlane,null],[C.funcDef_PlaneNorm,null],[C.funcDef_RayPlaneIntersection,null],[C.funcDef_RaySphereIntersection,null],[C.funcDef_RayPoint,null],[C.funcDef_SpecularReflection,null],[C.funcDef_RayCollision,t.intersection],[C.funcDef_PhotonMapGenerate,null],[C.funcDef_Distance,null],[C.funcDef_Main,null]],n="";for(let t=0;t<e.length;t++)console.log(e[t][0]),null===e[t][1]?n+=e[t][0]():(console.log(e[t][1]),n+=e[t][0](e[t][1]));return n}static globalVarDefConcat(){return"\n            uvec2 seeds = uvec2(1.0,1.0);\n            in vec3 ray;\n            in vec2 tex;\n            out vec4 fragmentColor;\n        "}static uniformDefConcat(t){return null==t?"":t.getSourceFragment()}static getFragmentShader(t,e){null==t&&(t={intersection:"",ambientSetting:"",pointlight:""});let n="#version 300 es\n            precision lowp float;\n            precision lowp int;\n        \n";return n+=C.uniformDefConcat(e),n+=C.globalVarDefConcat(),n+=C.structDefConcat(),n+=C.funcDefConcat(t),n}}class w{constructor(t,e,n){this.cl=new u(1,1,1,1),this.em=new u(1,1,1,1),this.tp=w.DIFFUSE,null!=t&&(this.cl=t),null!=e&&(this.em=e),null!=n&&(this.tp=n)}}w.DIFFUSE=1,w.SPECULAR=2;class E{constructor(t,e,n,r){this.vc=t,this.ra=e,this.name="RTSphere"+r,null!=this.va&&null!=this.vb&&null!=this.vc||console.log("[CGProject] RTSphere: Invalid sphere object."),this.material=new w,null!=this.material&&(this.material=n),this.uEM=this.name+"_EM",this.uCL=this.name+"_CL"}updateMap(t){t.insert(this.name+"_VC",this.vc.getGLMatVec3(),p.VEC3),t.insert(this.name+"_RA",this.ra,p.FLOAT),t.insert(this.name+"_EM",this.material.em.getGLMatVec4(),p.VEC4),t.insert(this.name+"_CL",this.material.cl.getGLMatVec4(),p.VEC4)}genObject(){let t="";return t="sSphere("+this.name+"_VC,"+this.name+"_RA,"+this.name+"_EM,"+this.name+"_CL)",t}genShaderIntersection(){return"\n\n                if(true){\n                    sSphere sp = "+this.genObject()+";\n                    tc = fRaySphereIntersection(r,sp);\n                    if(tc>0.0 && tc<t){\n                        t=tc;\n                        norm = fRayPoint(r,tc) - "+this.name+"_VC;\n                        emicolor = vec4("+this.uEM+");\n                        matcolor = vec4("+this.uCL+");\n                        hitType = "+this.material.tp+";\n                        collided=true;\n                    }\n                }\n        "}}class A{constructor(t,e,n,r,i){this.va=t,this.vb=e,this.vc=n,this.name="RTPlane"+i,null!=this.va&&null!=this.vb&&null!=this.vc||console.log("[CGProject] RTPlane: Invalid plane object."),this.material=new w,null!=this.material&&(this.material=r),this.uEM=this.name+"_EM",this.uCL=this.name+"_CL"}updateMap(t){t.insert(this.name+"_VA",this.va.getGLMatVec3(),p.VEC3),t.insert(this.name+"_VB",this.vb.getGLMatVec3(),p.VEC3),t.insert(this.name+"_VC",this.vc.getGLMatVec3(),p.VEC3),t.insert(this.name+"_EM",this.material.em.getGLMatVec4(),p.VEC4),t.insert(this.name+"_CL",this.material.cl.getGLMatVec4(),p.VEC4)}genObject(){let t="";return t="sPlane("+this.name+"_VA,"+this.name+"_VB,"+this.name+"_VC,"+this.name+"_EM,"+this.name+"_CL)",t}genShaderIntersection(){return"\n                if(true){\n                    sPlane pl = "+this.genObject()+";\n                    tc = fRayPlaneIntersection(r,pl);\n                    if(tc>0.0){\n                        vec3 ip = fRayPoint(r,tc);\n                        if(fInsidePlane(pl,ip)){\n                            if(tc<t){\n                                t=tc;\n                                norm = fPlaneNorm(pl);\n                                emicolor = vec4("+this.uEM+");\n                                matcolor = vec4("+this.uCL+");\n                                hitType = "+this.material.tp+";\n                                collided=true;\n                            }\n                        }\n                    }\n                }\n            \n        "}}const M=new class{constructor(t){let e=document.getElementById(t);this.context=e.getContext("webgl2"),this.context||window.alert("[CGProject] WGL is not supported!")}getContext(){return this.context}}("webgl_displayer").getContext();let _=new class extends n{constructor(t){super(t),this.gl=t,this.vertexShader="  ",this.fragmentShader="  "}getFragShader(){return this.fragmentShader="\n        varying lowp vec4 vColor;\n        varying highp vec4 vPosition;\n        varying highp vec3 vAmbientLight;\n        varying highp vec2 vTextureCoord;\n        uniform int uUsingTex;\n\n        uniform sampler2D uSampler;\n        int temp;\n        //Update\n        void main() {\n            highp vec4 ret;\n            if(uUsingTex==0){\n                ret = vec4(vColor.xyz * vAmbientLight,vColor.w);\n            }else{\n                highp vec4 tex = texture2D(uSampler,vec2(vTextureCoord.s,vTextureCoord.t));\n                ret = tex;\n                \n            }\n            ret = ret * vec4(vAmbientLight,1.0);\n            gl_FragColor = ret;\n            \n        }\n        ",this.fragmentShader}getVertexShader(){return this.vertexShader="\n        attribute vec4 aVertexPosition;\n        attribute vec4 aVertexColor;\n        attribute vec2 aTextureCoord;\n\n        uniform mat4 uModelViewMatrix;\n        uniform mat4 uProjectionMatrix;\n        uniform vec3 uAmbientLight;\n\n        varying lowp vec4 vColor;\n        varying highp vec4 vPosition;\n        varying highp vec3 vAmbientLight;\n        varying highp vec2 vTextureCoord;\n\n        void main() {\n          gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\n          vColor = aVertexColor;\n          vAmbientLight = uAmbientLight;\n          vTextureCoord = aTextureCoord;\n          vPosition = aVertexPosition;\n        }\n        ",this.vertexShader}getShaderProgram(){return this.getShaderProgramEx(this.getVertexShader(),this.getFragShader())}getLocationsInfo(){let t=this.getShaderProgram();return{program:t,attribLocations:{vertexPosition:this.gl.getAttribLocation(t,"aVertexPosition"),vertexColor:this.gl.getAttribLocation(t,"aVertexColor"),vertexTexture:this.gl.getAttribLocation(t,"aTextureCoord")},uniformLocations:{projectionMatrix:this.gl.getUniformLocation(t,"uProjectionMatrix"),modelViewMatrix:this.gl.getUniformLocation(t,"uModelViewMatrix"),ambientLight:this.gl.getUniformLocation(t,"uAmbientLight"),usingTex:this.gl.getUniformLocation(t,"uUsingTex"),sampler:this.gl.getUniformLocation(t,"uSampler")}}}}(M).getLocationsInfo(),F=new g;F.setOrtho(-1,1,1,-1,-1,1),F.setCamPosition(new o(0,0,-1)),F.setCamCenter(new o(0,0,0)),F.setCamUp(new o(0,1,0));let S=new u(1,1,1,1),D=new o(-1,-1,0),P=new o(-1,1,0),V=new o(1,-1,0),L=new o(1,1,0),U=new o(1,0),B=new o(1,1),I=new o(0,0),O=new o(0,1),G=new class extends class{constructor(){this.vertices=new Array,this.colors=new Array,this.texture=new Array,this.vertexlist=new Array,this.ready=!1}addVertex(t){this.vertexlist.push(t),this.ready=!1}eval(){if(!0!==this.ready){this.vertices=new Array,this.colors=new Array,this.texture=new Array;for(let t=0;t<this.vertexlist.length;t++){let e=this.vertexlist[t];this.vertices.push(e.pt.x),this.vertices.push(e.pt.y),this.vertices.push(e.pt.z),this.colors.push(e.cl.r),this.colors.push(e.cl.g),this.colors.push(e.cl.b),this.colors.push(e.cl.a),this.texture.push(e.tx.x),this.texture.push(e.tx.y)}this.ready=!0}}clear(){this.vertexlist=[],this.ready=!1}}{constructor(t,e,n,r){super(),this.set(t,e,n,r)}set(t,e,n,r){this.va=t,this.vb=e,this.vc=n,this.vd=r,this.addVertex(this.va),this.addVertex(this.vb),this.addVertex(this.vc),this.addVertex(this.vd),this.addVertex(this.vc),this.addVertex(this.vb),this.eval()}getNormalVector(){this.va.add(this)}}(new r(D,S,U),new r(P,S,B),new r(V,S,I),new r(L,S,O)),j=new class extends class{constructor(){this.vbuf=new Array,this.ambientLight=new l}addShape(t){this.vbuf.push(t)}setAmbientLight(t){this.ambientLight=t}}{constructor(t){super(),this.gl=t,this.fb=new h(t),this.usingTex=0}getFrameBuffer(){return this.fb}getGLVertexArray(){let t=this.gl,e=[],n=[],r=[],i=0;for(let t=0;t<this.vbuf.length;t++){let a=this.vbuf[t];a.eval(),e=e.concat(a.vertices),n=n.concat(a.colors),r=r.concat(a.texture),i+=a.vertexlist.length}window.w={v:e,t:r,c:n};const a=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,a),t.bufferData(t.ARRAY_BUFFER,new Float32Array(e),t.STATIC_DRAW);const s=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,s),t.bufferData(t.ARRAY_BUFFER,new Float32Array(n),t.STATIC_DRAW);const o=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,o),t.bufferData(t.ARRAY_BUFFER,new Float32Array(r),t.STATIC_DRAW);let l={vb:a,cb:s,tb:o,vnum:i};return window.r=l,l}render(t,e,n){let r=this.gl;r.clearColor(0,0,0,1),r.clearDepth(1),r.clear(r.COLOR_BUFFER_BIT|r.DEPTH_BUFFER_BIT),r.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height),this.renderInternal(t,e,n)}renderInternal(t,e,n,r){let i=this.gl,a=e.getMatrix(),s=a.proj,o=a.view;const l=this.getGLVertexArray();i.bindBuffer(i.ARRAY_BUFFER,l.vb),i.vertexAttribPointer(t.attribLocations.vertexPosition,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(t.attribLocations.vertexPosition),i.bindBuffer(i.ARRAY_BUFFER,l.cb),i.vertexAttribPointer(t.attribLocations.vertexColor,4,i.FLOAT,!1,0,0),i.enableVertexAttribArray(t.attribLocations.vertexColor),this.usingTex&&(i.bindBuffer(i.ARRAY_BUFFER,l.tb),i.vertexAttribPointer(t.attribLocations.vertexTexture,2,i.FLOAT,!1,0,0),i.enableVertexAttribArray(t.attribLocations.vertexTexture)),i.useProgram(t.program),i.uniformMatrix4fv(t.uniformLocations.projectionMatrix,!1,s),i.uniformMatrix4fv(t.uniformLocations.modelViewMatrix,!1,o),i.uniform3fv(t.uniformLocations.ambientLight,this.ambientLight.light.getGLMatVec3()),i.activeTexture(i.TEXTURE0),null!=n&&(n.disableMips(),n.start()),i.uniform1i(t.uniformLocations.usingTex,this.usingTex),i.uniform1i(t.uniformLocations.sampler,0),null!=r&&r.end(),i.drawArrays(i.TRIANGLES,0,l.vnum),null!=n&&n.end()}renderToTexture(t,e,n){let r=this.gl;this.fb.start(),n.start(),r.viewport(0,0,n.getW(),n.getH()),r.clearColor(0,0,0,1),r.clear(r.COLOR_BUFFER_BIT|r.DEPTH_BUFFER_BIT),this.renderInternal(t,e,null,n),n.end(),this.fb.end()}}(M);j.addShape(G),j.usingTex=1,M.enable(M.DEPTH_TEST),M.depthFunc(M.LEQUAL);let N=new class{constructor(t){this.gl=t,this.shaderVar=new p,this.screen=new g,this.observer=new T(t),this.shader=new b(t),this.compiledShader=null,this.geometryList=[],this.renderOutput=[new m(t,512,512,null),new m(t,512,512,null)],this.renderOutput[0].disableMips(),this.renderOutput[1].disableMips(),this.frameBuffer=new h(t),this.frameBuffer.bindTexturePingPong(t.COLOR_ATTACHMENT0,this.renderOutput[0],this.renderOutput[0]),this.startTimestamp=Date.now(),this.sampleCount=0,this.sheetRect=[-1,-1,0,-1,1,0,1,-1,0,1,1,0],this.sheetTex=[0,0,0,1,1,0,1,1],this.sheetColor=[0,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1],this.sheetvb=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.sheetvb),t.bufferData(t.ARRAY_BUFFER,new Float32Array(this.sheetRect),t.STATIC_DRAW),this.sheetcb=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.sheetcb),t.bufferData(t.ARRAY_BUFFER,new Float32Array(this.sheetColor),t.STATIC_DRAW),this.sheettb=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.sheettb),t.bufferData(t.ARRAY_BUFFER,new Float32Array(this.sheetTex),t.STATIC_DRAW),t.bindBuffer(t.ARRAY_BUFFER,null),this.screen.setOrtho(-1,1,1,-1,-1,1),this.screen.setCamCenter(new o(0,0,-1)),this.screen.setCamUp(new o(0,1,0)),this.screen.setCamPosition(new o(0,0,0)),this.pointlights=new Array,this.ambientLight=new v(new u(0,0,0,1)),this.skylight=new R(new u(0,0,0,1))}clear(){this.geometryList=[],this.shaderVar.clear(),this.pointlights=[]}attach(t){t instanceof v?this.ambientLight=t:t instanceof R?this.skylight=t:t instanceof class{constructor(t,e,n,r){window.alert("请不要使用点光源！"),this.cl=new u(1,1,1,1),this.pos=new o(0,0,0),this.atu=new o(0,0,0),null!=t&&(this.pos=t),null!=e&&(this.col=e),null!=n&&(this.atu=n),this.name="RTPointLight"+r}updateMap(t){t.insert(this.name+"_PS",this.pos.getGLMatVec3(),p.VEC3),t.insert(this.name+"_AT",this.atu.getGLMatVec3(),p.VEC3)}genShaderTest(){return window.alert("请不要使用点光源！"),"\n                if(true){\n                    if(fShadowLight("+this.name+"_PS,cp)==false){\n                        float dst = length(cp-"+this.name+"_PS);\n                        intensity=min(1.0,1.0/("+this.name+"_AT.x+"+this.name+"_AT.y*dst+"+this.name+"_AT.z*dst*dst));\n                    }\n                }\n        "}}?this.pointlights.push(t):this.geometryList.push(t)}getRenderOutput(){return this.renderOutput[0]}loadAlternativeTexture(){this.shaderVar.insert("uTexture",0,p.SAMPLER2D,this.renderOutput[1].getTexture())}updateMap(){for(let t=0;t<this.geometryList.length;t++)this.geometryList[t].updateMap(this.shaderVar);for(let t=0;t<this.pointlights.length;t++)this.pointlights[t].updateMap(this.shaderVar);this.observer.prepareShaderMap(this.shaderVar),this.ambientLight.updateMap(this.shaderVar),this.skylight.updateMap(this.shaderVar),this.shaderVar.insert("uProjectionMatrix",this.screen.getMatrix().proj,p.MAT4),this.shaderVar.insert("uModelViewMatrix",this.screen.getMatrix().view,p.MAT4),this.shaderVar.insert("uTime",Date.now()-this.startTimestamp,p.FLOAT),this.shaderVar.insert("uSamples",this.sampleCount,p.INT),this.loadAlternativeTexture()}genIntersectionJudge(){let t="";for(let e=0;e<this.geometryList.length;e++)t+=this.geometryList[e].genShaderIntersection();return t}genSpotlightJudge(){let t="";for(let e=0;e<this.pointlights.length;e++)t+=this.pointlights[e].genShaderTest();return t}genFragmentShader(){this.updateMap();let t={intersection:this.genIntersectionJudge(),ambientSetting:this.ambientLight.genCode()+this.skylight.genCode(),pointlight:this.genSpotlightJudge()};return C.getFragmentShader(t,this.shaderVar)}resetCounter(){this.sampleCount=0}compile(){this.compiledShader=this.shader.getShaderProgram(this)}updateUniform(){this.shaderVar.insert("uTime",(new Date).getTime()-this.startTimestamp,p.FLOAT),this.shaderVar.insert("uSamples",this.sampleCount,p.INT),console.log(this.sampleCount)}clear(){this.frameBuffer.start(),this.renderOutput[0].start(),gl.viewport(0,0,this.getRenderOutput().getW(),this.getRenderOutput().getH()),gl.clearColor(0,0,0,1),gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT),this.renderOutput[0].end(),this.frameBuffer.end()}render(t=!0,e=!1){let n=this.gl;this.frameBuffer.bindTexturePingPong(n.COLOR_ATTACHMENT0,this.renderOutput[0],this.renderOutput[1]),this.frameBuffer.start(),this.renderOutput[0].start(),this.renderOutput[0].disableMips(),this.renderOutput[1].disableMips(),n.viewport(0,0,this.getRenderOutput().getW(),this.getRenderOutput().getH()),n.clearColor(0,0,0,1),t&&(n.useProgram(this.compiledShader),this.shaderVar.bindShaderVarible(n,this.compiledShader),this.updateUniform(),this.loadAlternativeTexture(),n.bindBuffer(n.ARRAY_BUFFER,this.sheetcb),n.vertexAttribPointer(n.getAttribLocation(this.compiledShader,"aVertexColor"),4,n.FLOAT,!1,0,0),n.enableVertexAttribArray(n.getAttribLocation(this.compiledShader,"aVertexColor")),n.bindBuffer(n.ARRAY_BUFFER,this.sheetvb),n.vertexAttribPointer(n.getAttribLocation(this.compiledShader,"aVertexPosition"),3,n.FLOAT,!1,0,0),n.enableVertexAttribArray(n.getAttribLocation(this.compiledShader,"aVertexPosition"))),n.drawArrays(n.TRIANGLE_STRIP,0,4),this.sampleCount++,this.renderOutput[0].end(),this.frameBuffer.end(),this.renderOutput.reverse()}}(M),X=new E(new o(0,-.45,8),.5,new w(new u(.8,.8,.8,1),new u(0,0,0,1),w.DIFFUSE),"sphere1"),Y=new E(new o(-.6,-.8,7),.3,new w(new u(1,0,0,1),new u(0,0,0,1),w.DIFFUSE),"sphere2"),k=new E(new o(.6,-.8,7),.3,new w(new u(1,1,1,1),new u(5,5,5,1),w.DIFFUSE),"light1"),H=(new A(new o(-6,0,-6),new o(-6,0,40),new o(40,0,-6),new w(new u(.75,.75,.75,1),new u(0,0,0,1),w.DIFFUSE),"ground1"),new A(new o(2,2,0),new o(2,3,0),new o(3,2,0),new w(new u(.75,.75,.75,1),new u(0,0,0,1),w.DIFFUSE),"ground2"),new E(new o(0,-100,22),100,new w(new u(.8,.8,.8,1),new u(0,0,0,1),w.DIFFUSE),"ground"));new v(new u(.1,.1,.1,1)),new R(new u(.2,.5,.7,1)),N.attach(H),N.attach(X),N.attach(Y),N.attach(k),N.compile(),N.render(!0);let W=0,q=0,J=Date.now(),K=document.getElementById("sample"),Q=document.getElementById("sample641");requestAnimationFrame((function t(){W+=1,K.innerHTML="SAMPLES:"+W+", RenderFPS:"+parseInt(1e3*W/(Date.now()-J)),Q.innerHTML=" DisplayedFrames:"+q+", DispFPS:"+parseInt(1e3*q/(Date.now()-J)),N.render(),q++,j.render(_,F,N.getRenderOutput()),requestAnimationFrame(t)}))})();
<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>(ML/CV) 样本分布不平衡的问题的解决策略调研</title>
    <link href="/2022/10/17/ml-intern-1-long-tail/"/>
    <url>/2022/10/17/ml-intern-1-long-tail/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基于Re-weighting-Loss加权-的方法"><a href="#1-基于Re-weighting-Loss加权-的方法" class="headerlink" title="1. 基于Re-weighting (Loss加权) 的方法"></a>1. 基于Re-weighting (Loss加权) 的方法</h2><p>这一类方法通过修正不同类别的Loss权重，达成对长尾分布中尾部类别的补偿</p><h3 id="1-1-Class-Balanced-Loss-Based-on-Effective-Number-of-Samples-CVPR2019"><a href="#1-1-Class-Balanced-Loss-Based-on-Effective-Number-of-Samples-CVPR2019" class="headerlink" title="1.1 Class-Balanced Loss Based on Effective Number of Samples (CVPR2019)"></a>1.1 Class-Balanced Loss Based on Effective Number of Samples (CVPR2019)</h3><h4 id="研究动机"><a href="#研究动机" class="headerlink" title="研究动机"></a>研究动机</h4><ul><li>解决长尾分布的通常方法包括重采样(Re-sampling)和Loss加权&#x2F;重加权(Re-weighting)两种方法。对于重采样，对头部分类(主要类别)欠采样可能导致丢弃有价值的样本，而过采样会导致引入重复样本，造成过拟合或者延长训练时间。因此Re-weighting的方法更好</li><li>通常对Loss加权的权重 $w_i$反比与类别的$i$样本数量$c_i$，但是已有证明这样效果不好。因此，一种新的Re-weighting的方法对于处理长尾问题有价值</li></ul><h4 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h4><ul><li>提出了一种基于Reweighting的长尾训练方法，使用“有效样本数量” (Effective Number of Samples)设计Loss中关于分类的加权项(即class-balance term)的取值。</li><li>在常用的Loss函数（如Sigmoid交叉熵、Softmax交叉熵、Focal Loss等）前附加上述的加权系数，就能够实现较好的性能提升。</li></ul><h4 id="算法内容"><a href="#算法内容" class="headerlink" title="算法内容"></a>算法内容</h4><p><strong>问题定义</strong></p><p>​作者将采样过程定义为一个简化的随机覆盖问题。数据集中的样本不再被看成一个单独的点，而是被看做一个小块的区域。即每一个样本可能和其它的样本之间有一定概率重合。设同一类的样本在特征空间中构成的集合为$S$，容量(原文是Volume，这里翻译可能不正确)是$N$，每一个其中样本具有单位容量$1$。</p><p>​有效样本数量(Effective number of samples)定义为集合的期望容量。</p><p>​采样过程被定义为一个覆盖过程，一个新采样的样本有$p$概率在已经采样的样本构成的集合中，有$(1-p)$概率在其之外。另外类别中样本越多，新采样的样本被已采样的样本覆盖的可能性更高。这里的覆盖表征的是同一类别中两个不同样本的相似性，$N$越大，表示着$S$中原始的独特样本越多（即数据增强之前的差别大的样本）。</p><p><strong>系数计算</strong></p><p>​定义 $E_n$为采样$S$中$n$个样本时，获得的期望有效样本数量的个数，那么可以根据数学归纳法推出<br>$$<br>E_n&#x3D;\frac{1-\beta^n}{1-\beta}<br>$$<br>​其中超参$\beta&#x3D;(N-1)&#x2F;N$，如果$\beta\to1$表示类别中每一个样本都是独一无二的；反之$\beta\to0$表示所有样本都重叠。</p><p><strong>修正Loss</strong></p><p>​在实践中，对于每一个类别需要设定一个$N_i,\beta_i$，但是实现起来不方便（超参不好确定），因此可以对一个数据集下的所有类别使用同一个超参$N$和$\beta$。设$n_i$为第$i$类的样本数，则定义权重参数$c_i$<br>$$<br>c_i&#x3D;\frac{1}{E_{n_i}}<br>$$<br>​保证Loss的尺度在加上权重项和之前一样，对其归一化得到规范化权重参数$\alpha_i$，其中$C$是总共类别数量<br>$$<br>\alpha_i&#x3D;\frac{c_iC}{\sum_{i&#x3D;1}^C c_i}<br>$$<br>​在原有Loss前附加一个修正项$\alpha_i$即得到类平衡(Class-balanced)修正后的Loss函数。比如Class-balanced Softmax如下<br>$$<br>CB_{softmax}(\mathbf{z},y)&#x3D;-\alpha_{n_y}\log\left(\frac{\exp(z_y)}{\sum_{i&#x3D;1}^C\exp(z_i)}\right)<br>$$</p><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>在Longtail CIFAR-10上，使用超参$\beta&#x3D;0.9999$，约降低使用系数之前3%的错误率。</p><p>在Longtail CIFAR-100上，使用超参$\beta&#x3D;0.99$和FocalLoss或Sigmoid时，降低使用系数之前1%错误率</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><strong>PyTorch:</strong> <a href="https://github.com/vandit15/Class-balanced-loss-pytorch">https://github.com/vandit15/Class-balanced-loss-pytorch</a></p><h3 id="1-2-Distributional-Robustness-Loss-for-Long-tail-Learning-ICCV2021"><a href="#1-2-Distributional-Robustness-Loss-for-Long-tail-Learning-ICCV2021" class="headerlink" title="1.2 Distributional Robustness Loss for Long-tail Learning (ICCV2021)"></a>1.2 Distributional Robustness Loss for Long-tail Learning (ICCV2021)</h3><h4 id="研究动机-1"><a href="#研究动机-1" class="headerlink" title="研究动机"></a>研究动机</h4><ul><li>传统训练策略遵循最小化经验风险(Empirical Risk Minimization)的策略，缺陷是训练分布和真实(测试)分布一致，这显然是难以实现的。因此，引入Distributionally Robust Optimization (DRO) 能够有效解决长尾问题。（鲁棒性优化还没看）</li><li>将DRO的思想引入到长尾Loss的设计上：已有小样本的中心和其实际分布中心差距很大，通过DRO优化可能的最坏情况可以缓解这一问题。</li></ul><h4 id="主要贡献-1"><a href="#主要贡献-1" class="headerlink" title="主要贡献"></a>主要贡献</h4><ul><li>将数据不平衡下的学习问题，定义为鲁棒性优化问题。</li><li>设计了一个新的Loss，DRO-LT。基于DRO-LT训练能够同时覆盖头部和尾部分类表征</li><li>在CIFAR100-LT等数据集上测试，得到了好的效果。</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p><strong>PyTorch</strong>: <a href="https://github.com/dvirsamuel/DRO-LT">https://github.com/dvirsamuel/DRO-LT</a></p><h3 id="1-3-Asymmetric-Loss-For-Multi-Label-Classification-ICCV2021"><a href="#1-3-Asymmetric-Loss-For-Multi-Label-Classification-ICCV2021" class="headerlink" title="1.3 Asymmetric Loss For Multi-Label Classification (ICCV2021)"></a>1.3 Asymmetric Loss For Multi-Label Classification (ICCV2021)</h3><h4 id="研究动机-2"><a href="#研究动机-2" class="headerlink" title="研究动机"></a>研究动机</h4><ul><li>多任务语境下正负标签数量不均衡，一张图可能有几个Positive的标签，但是有很多Negative的标签。（Positive-negative imbalance）</li></ul><h4 id="主要贡献-2"><a href="#主要贡献-2" class="headerlink" title="主要贡献"></a>主要贡献</h4><ul><li>提出了基于Positive-negative imbalance和解决Groundtruth错误标签(Mis-labeling)的“非对称Loss” (Asymmetric Loss, ASL)</li><li>研究了ASL的性质，提出了控制Loss超参的一些方法</li><li>在MS-COCO数据集上取得了更好的效果，且不需要花费额外推理和训练时间</li></ul><h4 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h4><p><strong>非对称聚焦</strong></p><p>​类比于Focal Loss的$\gamma$值，作者将其对正负样本解耦，即定义$\gamma_+$和$\gamma_-$，之后正类别Loss$L_+$和负类别Loss$L_-$定义为<br>$$<br>L_+&#x3D;(1-p)^{\gamma_+}\log(p);L_-&#x3D;p^{\gamma_-}\log(1-p)<br>$$<br>​根据经验，有约束$\gamma_-&gt;\gamma_+$。解耦有效地降低了低概率情况下，负样本对</p><p><strong>非对称概率分布偏移</strong></p><p>​由于多标签分类中的不平衡程度可能非常高，因此这种衰减(非对称聚焦)并不总是足够的。基于此，作者提出了额外的非对称机制，即非对称概率偏移。记偏移后的概率是$p_m$，则<br>$$<br>p_m&#x3D;\max(p-m,0)<br>$$<br><strong>ASL定义</strong></p><p>​基于以上的非对称机制，可以定义ASL函数，即<br>$$<br>L_+&#x3D;(1-p)^{\gamma_+}\log(p);L_-&#x3D;p^{\gamma_-}_m\log(1-p_m)<br>$$</p><h4 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h4><p>​在MS-COCO数据集上较原有的SOTA模型，mAP提高2.8%；Pascal-VOC上，较原有SOTA模型，mAP提高0.6%；</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p><strong>PyTorch</strong>： <a href="https://github.com/Alibaba-MIIL/ASL">https://github.com/Alibaba-MIIL/ASL</a></p><h2 id="2-基于Re-sample-重采样-的方法"><a href="#2-基于Re-sample-重采样-的方法" class="headerlink" title="2. 基于Re-sample (重采样) 的方法"></a>2. 基于Re-sample (重采样) 的方法</h2><p>这一类方法通过修正采样时不同类别的采样概率，达成对长尾分布中尾部类别的补偿</p><h3 id="2-1-Decoupling-representation-and-classifier-for-long-tailed-recognition-ICLR2020"><a href="#2-1-Decoupling-representation-and-classifier-for-long-tailed-recognition-ICLR2020" class="headerlink" title="2.1 Decoupling representation and classifier for long-tailed recognition (ICLR2020)"></a>2.1 Decoupling representation and classifier for long-tailed recognition (ICLR2020)</h3><h4 id="研究动机-3"><a href="#研究动机-3" class="headerlink" title="研究动机"></a>研究动机</h4><ul><li>已有研究缺乏对长尾学习效果的分析——一个好的模型来自于其更好的表征，还是通过对分类器中决策边界的移动达到对不平衡类别更好的效果。因此作者将模型训练拆成了特征学习和分类两部分，进行实验。</li></ul><h4 id="主要贡献-3"><a href="#主要贡献-3" class="headerlink" title="主要贡献"></a>主要贡献</h4><ul><li>全程对分类器按照Class-balanced的方式采样（即每一个类别采样概率相同），效果不一定好。</li><li>对一个训练好的Joint Model（即原有模型，包括特征提取部分+分类器）的分类器按Class-Balanced进行Retrain效果更好。</li><li>将这个训练策略应用到常见模型上，在ImageNet-LT，Places-LT，iNaturalist上效果超出已有的SOTA模型</li></ul><h4 id="算法内容-1"><a href="#算法内容-1" class="headerlink" title="算法内容"></a>算法内容</h4><p><strong>采样策略定义</strong></p><p>一个类别$j$中的样本被采样到的概率定义如下，其中$n_j^q$表示第$j$类中的样本数量，$C$为类别数量。<br>$$<br>p_j&#x3D;\frac{n_j^q}{\sum_{i&#x3D;1}^Cn_i^q}<br>$$<br>参数$q$则定义了采样策略。对于$q&#x3D;1$，则每一个样本有均等概率取得，此时采样策略是Instance-balanced（基于实例平衡的）的；对于$q&#x3D;0$，则每一个类别有均等概率取得，此时采样策略是Class-balanced（基于类别平衡的）的。中间值则是这两种方法的混合。</p><p><strong>分类器调整策略定义</strong></p><p>将联合模型（Joint Model，即原有模型，包括特征提取部分+分类器）训练好后，冻结特征提取部分网络参数，调整分类器参数的过程称为分类器的调整。作者给出了三种调整策略。</p><ul><li>**分类器重训练 Classfier Re-training (cRT)**：按照Class-balanced策略对分类器参数重置后训练</li><li>**最近类别均值分类器 Nearset Class Mean classifier (NCM)**：先使用训练集计算出个类别的中心 feature tensor，然后每次做预测的时候使用 cosine similarity或者 MSE loss计算出每个样本离这些中心feature的距离。</li><li><strong>τ-normalized classifier</strong> ：给最后一层的分类器加上正则限制，防止其都预测成类别多的那类。即对第$i$类的分类器参数$w_i$除以$w_i$对的$\tau$范数</li></ul><h4 id="实验结果-2"><a href="#实验结果-2" class="headerlink" title="实验结果"></a>实验结果</h4><p>对于长尾类别，使用Instance-balanced的方法对联合模型训练完后，使用cRT或者τ-norm的方法进行分类器调整效果最好，提高的精确度达到25%左右；对于整体，准确率提升在5%左右。</p>]]></content>
    
    
    
    <tags>
      
      <tag>(CS)Computer Vision</tag>
      
      <tag>(CS)Machine Learning</tag>
      
      <tag>(MI)Intern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(CG) 基于WebGL实现的光线追踪渲染</title>
    <link href="/2022/02/23/cg-course-1-raytracing/"/>
    <url>/2022/02/23/cg-course-1-raytracing/</url>
    
    <content type="html"><![CDATA[<h2 id="〇、前言"><a href="#〇、前言" class="headerlink" title="〇、前言"></a>〇、前言</h2><p>本文是课程 计算机图形学 的课程报告</p><p>本文共同作者信息见 <a href="https://github.com/Aeroraven/Ray-tracing">https://github.com/Aeroraven/Ray-tracing</a></p><h2 id="一、-理论内容"><a href="#一、-理论内容" class="headerlink" title="一、 理论内容"></a>一、 理论内容</h2><h3 id="1-光线追踪"><a href="#1-光线追踪" class="headerlink" title="1. 光线追踪"></a>1. 光线追踪</h3><p>​我们选用的常规渲染方法是光线追踪，与传统的光栅化渲染不同，光线追踪是把对一个场景的渲染任务分解成摄像机发出的若干光线对场景的影响。每条光线会和场景并行地求交，根据交点位置获取表面的材质、纹理等信息，并结合光源信息计算光强。</p><h4 id="1-1-渲染方程"><a href="#1-1-渲染方程" class="headerlink" title="1.1 渲染方程"></a>1.1 渲染方程</h4><p>​根据从视点处发出的光线，计算光线和物体的交点，我们可以列出下列渲染方程得到光线颜色其中$L_e$是物体自身的出射辐射(自发光)，$w_i$为物体散射函数(取决于物体表面材质)$L_i$是入射辐射度(入射光)，$cos\theta$是入射光线和法线之间的夹角余弦。<br>$$<br>L_o(p,\omega_0)&#x3D;L_e(p,\omega_0)+\int_{\xi^2}f_r(p,w_i\to w_0)L_i(p,\omega_i)cos\theta d\omega_i<br>$$</p><h4 id="1-2-蒙特卡洛积分"><a href="#1-2-蒙特卡洛积分" class="headerlink" title="1.2 蒙特卡洛积分"></a>1.2 蒙特卡洛积分</h4><p>​对于镜面反射，反射方向是可以直接确定的。对于漫反射，反射光线遍布所有方向，由于积分难以直接计算，我们使用蒙特卡洛积分法对该积分近似求解，每次随机选取一个反射反射方向计算光线的辐射信息，这样一次渲染的过程就可以近似为<br>$$<br>L_o(p,\omega_0)&#x3D;L_e(p,\omega_0)+f_r(p,w_i\to w_0)L_i(p,\omega_i)cos\theta<br>$$</p><h4 id="1-3-路径追踪算法"><a href="#1-3-路径追踪算法" class="headerlink" title="1.3 路径追踪算法"></a>1.3 路径追踪算法</h4><p>​从视点发射光线计算颜色的过程是上述方程进行逆向计算的过程。对于光线所碰到的第p个物体，其对视点感知到的辐射度的贡献值可以标识为：<br>$$<br>L_{o,p}&#x3D;\left(\prod_{k&#x3D;0}^{p-1}f_{r,k}L_{i,k}\right)L_{e,p};L_o&#x3D;\sum_{k&#x3D;0}^NL_{o,k}<br>$$<br>之后迭代计算光照的辐射信息，并记录采样数，对N次采样结果取平均值即得到光想追踪的渲染结果。</p><h4 id="1-4-Ping-Pong-缓冲"><a href="#1-4-Ping-Pong-缓冲" class="headerlink" title="1.4 Ping Pong 缓冲"></a>1.4 Ping Pong 缓冲</h4><p>​为了能够实时地观察到渲染的结果，我们利用WebGL的FrameBuffer实现了Ping Pong缓冲机制。一次计算的时候将上一次光线追踪计算出的结果<code>（Texture A）</code>渲染出来，而当前光线追踪则将计算的结果写入到另一个地方<code>（Texture B）</code>中。当一次计算完成后，将<code>Texture A</code>和<code>Texture B</code> 进行交换。为了将Ping Pong和蒙特卡洛积分进行结合，程序向片段着色器传入一个值<code>uSample</code>表示已有的采样数量，并将已经渲染出的结果<code>（Texture A）</code>同样传入片段着色器中。最终的FragmentColor由<code>Texture A</code>（权重为<code>uSample</code>）和本次的光线追踪计算结果（权重为1）加权平均产生。</p><h4 id="1-5-Gamma校正"><a href="#1-5-Gamma校正" class="headerlink" title="1.5 Gamma校正"></a>1.5 Gamma校正</h4><p>​因为人眼对光线的感受不是线性的，举个例子，在黑暗时增加一盏灯，那时人眼的感受最明显，往后随着灯数量的增加，人眼对光亮的感觉不会这么明显，事实上<code>显示器输出&lt;人眼接收</code>，因此我们在图像处理的过程中尽可能得保留暗部细节，符合人眼的暗部敏感需求，我们的RGB值与功率的关系如下公式所示<br>$$<br>V_o&#x3D;V_i^{1&#x2F;\gamma}<br>$$</p><h3 id="2-光子映射"><a href="#2-光子映射" class="headerlink" title="2. 光子映射"></a>2. 光子映射</h3><p>​我们小组基于光线追踪的基础上，希望能够研究除了软光栅和光追踪之外其他相关的渲染方法，并且通过具体实现加以分析。我们小组选择的拓展方向是光子映射。根据相关的资料说明，我们了解到光子映射相较于光线追踪可以更好的解决 Caustics 等现象。但是，光子映射一般对内存空间的开销是比较大的。</p><p>​我们也从光子映射的原理出发开始学习。基本的光子映射可以分为两个阶段：构建光子贴图和基本全局光子映射。我们构建光子图，主要是存储从光源出发的所有光子通量信息；后续的基本全局光子映射和传统的路径追踪比较相似，但是在追踪到特定表面，比如漫反射表面的时候，我们根据光子图以及实时发射的光子信息计算最终的辐射率。</p><h4 id="2-1-光子贴图"><a href="#2-1-光子贴图" class="headerlink" title="2.1 光子贴图"></a>2.1 光子贴图</h4><h5 id="2-1-1-光子贴图的基本定义"><a href="#2-1-1-光子贴图的基本定义" class="headerlink" title="2.1.1 光子贴图的基本定义"></a>2.1.1 光子贴图的基本定义</h5><p>​我们可以用网上资料<sup>[1]</sup>如上图对于光子贴图进行解释说明。光源是会不断发射光子的，他们场景中不断弹射，每次击中漫反射表面，就可以在对应位置记录下相应的光子信息，这个过程会在两种情况下结束：要么光子能量低于一定的阈值，我们就看作光子被这个漫反射表面吸收了；要么使用俄罗斯轮盘赌，一旦随机数低于设定好的反射率，也强行停止。</p><p>​例如上图中，从顶上方的面光源发射光子分别弹射到墙壁、镜面球、玻璃球等不同材质，进行反射和折射直到被某处，上图为顶板和底板吸收。实际项目中，有例如数组、链表、kd树等多种方式存储光子贴图。</p><h5 id="2-1-2-光源和光子初始情况"><a href="#2-1-2-光源和光子初始情况" class="headerlink" title="2.1.2 光源和光子初始情况"></a>2.1.2 光源和光子初始情况</h5><p>​首先我们假定光源本身的辐射值是$$Le$$，那么当前光子的初始发射功率就可以表示为：<br>$$<br>\Phi&#x3D;\frac{L_e|cos\theta|}{pdf_A(x)pdf_w(\omega)}<br>$$<br>​和路径追踪类似地，我们在光子映射中也考虑点光源、面积光和平行光，可以分别计算得到光源法向量、面积和采样值。</p><h5 id="2-1-3-光子反射"><a href="#2-1-3-光子反射" class="headerlink" title="2.1.3 光子反射"></a>2.1.3 光子反射</h5><p>​当光子发射的射线和场景某一表面相交的时候，我们可以通过随机数或者BSDF的算法原理计算反射分布，也可以得到反射方向和反射类型。当反射类型是漫反射的时候，光子映射就需要将其记录到光子贴图。我们可以为光子构建结构体，往光子贴图中记录光子位置、路径和功率。</p><h5 id="2-1-4-光子吸收"><a href="#2-1-4-光子吸收" class="headerlink" title="2.1.4 光子吸收"></a>2.1.4 光子吸收</h5><p>​光子撞击漫反射表面时，在以下两种情况下会判定为被吸收：</p><ol><li>光子能量小于一定的阈值</li><li>被俄罗斯轮盘赌筛掉</li></ol><p>如果一个光子没有被吸收，我们可以更新下一次发射迭代时光子的功率。事实上，这里就可以体现出光子映射和路径追踪的理论区别，因为光子映射追踪的是功率，而路径追踪计算的是吞吐量。从原理上来说，我们可以先计算当前反射撞击到的材质的反射率：<br>$$<br>R&#x3D;\frac{f(x_{i-1}\to x_i\to x_{i+1})|cos\theta_i|}{pdf_\omega(x_i\to x_{i+1})}<br>$$<br>​随后再迭代计算下一次功率的具体值：<br>$$<br>\Phi_{i+1}&#x3D;\Phi_i\times\frac{R}{matProb},or,\Phi&#x3D;\Phi_i\times\frac{R}{N_{BxDF}}<br>$$<br>​两个等式使用不同方法对功率进行模拟，前者是SmallVCM，后者是PBRT。在实际项目中我们也可以通过其他方式对功率进行模拟。</p><h4 id="2-2-基本全局光子映射"><a href="#2-2-基本全局光子映射" class="headerlink" title="2.2 基本全局光子映射"></a>2.2 基本全局光子映射</h4><p>​经过上述阶段的光子贴图构建，我们可以实时获得光子的位置、方向和功率，这些属性我们都可以运用到后续的渲染过程中。我们可以从基本的基本渲染公式出发：<br>$$<br>L_r(x,\omega)&#x3D;\int_{\Omega}f(x,\omega’,\omega)L_i(x,\omega’)|cos\theta ‘|d\omega’<br>$$<br>​根据辐射率的定义，我们可以将以上公式转换为：<br>$$<br>L_r&#x3D;\int_\Omega f(x,\omega’,\omega)\frac{d^2\phi_i(x,\omega’)}{dA|cos\theta’|dw’}|cos\theta’|dw’&#x3D;\int_\Omega f(x,\omega’,\omega)\frac{d^2\Phi_i(x,\omega’)}{dA}<br>$$</p><h2 id="二、项目实现"><a href="#二、项目实现" class="headerlink" title="二、项目实现"></a>二、项目实现</h2><h3 id="1-WebGL渲染过程"><a href="#1-WebGL渲染过程" class="headerlink" title="1. WebGL渲染过程"></a>1. WebGL渲染过程</h3><h4 id="1-1-基本的WebGL渲染过程"><a href="#1-1-基本的WebGL渲染过程" class="headerlink" title="1.1 基本的WebGL渲染过程"></a>1.1 基本的WebGL渲染过程</h4><p>​本次项目实现的光线追踪算法主要由两次渲染过程组成。第一次渲染将光线追踪的结果输出至纹理上，第二次渲染将纹理绑定至一个矩形区域并输出到HTML的Canvas画布上。为了更加便捷地使用WebGL，我们使用OOP的思想重新封装了WebGL的API，在此基础上实现路径追踪和光子映射。</p><p>​Three.js和Babylon.js等Web3D库都使用面向对象的思想对一些渲染过程中常见的概念进行封装。受到这些项目的启发，本项目对光栅渲染中的一些常见的概念通过WebGL底层的API进行了重新的封装。例如项目中场景就封装于类WGLScene中、纹理处理封装于类WGLTexture中、帧缓冲处理封装于WGLFrameBuffer中、基本的三角形图元和矩形封装于类Triangle和Rect当中、相机封装于Camera类中。</p><p><strong>Camera 对象</strong> Camera对象位于项目的<code>core/Camera.js</code>文件当中，主要目标是提供模型视图变换（Model View）和投影变换（Projection View）。其中模型视图矩阵通过LookAtMatrix进行生成（即指定观察者位置、观察中心和上方向，生成一个模型视图矩阵）。投影变换支持透视投影（通过<code>setPerspective</code>方法）和正交投影（通过<code>setOrtho</code>方法）实现。Camera对象生成的两个矩阵在第二次渲染的过程中被送入光栅渲染部分的顶点着色器中</p><p><strong>WGLTexture 对象</strong> WGLTexture对象位于项目的<code>render/WGLTexture.js</code>文件当中，用于简化WebGL的纹理相关的操作，例如通过<code>texImage2D</code>创建纹理或<code>bindTexture</code>进行纹理的绑定以及对纹理Mipmap的相关操作、图片加载(<code>loadImageAsync</code>方法)、纹理更新(<code>updateTexture</code>方法)等操作。</p><p><strong>WGLFrameBuffer对象</strong> WGLFrameBuffer对象安慰与项目的<code>render/WGLFrameBuffer.js</code>文件当中，用于帧缓冲相关的处理。该部分内容将在下一小节进行阐述。</p><p><strong>WGLScene 对象</strong> WGLScene对象位于项目的<code>render/WGLScene.js</code>文件的当中，主要目标是将场景中的图形对象转换为顶点信息，并且执行渲染。在获得所有的图形顶点信息后，使用WebGL提供的<code>bindBuffer</code>和<code>bufferData</code>将顶点信息（包括顶点位置、顶点颜色和纹理坐标）传入光栅渲染部分的顶点着色器中，并执行渲染。WGLScene提供两种渲染方式，一种为直接渲染至Canvas画布，另一种为渲染至Texture（通过FrameBuffer和Texture共同实现）。二者共有的部分使用<code>renderInternal</code>方法进行封装。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Javascript Code: render/WGLScene.js</span><br><span class="hljs-title function_">renderInternal</span>(<span class="hljs-params">shaderInfo,camera,texture,fbtex</span>)&#123;<br>    <span class="hljs-keyword">let</span> gl = <span class="hljs-variable language_">this</span>.<span class="hljs-property">gl</span><br>    <span class="hljs-keyword">let</span> uniformMatrix = camera.<span class="hljs-title function_">getMatrix</span>()<br>    <span class="hljs-keyword">let</span> projectionMatrix = uniformMatrix.<span class="hljs-property">proj</span><br>    <span class="hljs-keyword">let</span> modelViewMat = uniformMatrix.<span class="hljs-property">view</span><br><br>    <span class="hljs-comment">//Get buffer</span><br>    <span class="hljs-keyword">const</span> buf = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getGLVertexArray</span>()<br><br>    <span class="hljs-comment">//Bind Vertex</span><br>    gl.<span class="hljs-title function_">bindBuffer</span>(gl.<span class="hljs-property">ARRAY_BUFFER</span>,buf.<span class="hljs-property">vb</span>)<br>    gl.<span class="hljs-title function_">vertexAttribPointer</span>(shaderInfo.<span class="hljs-property">attribLocations</span>.<span class="hljs-property">vertexPosition</span>,<span class="hljs-number">3</span>,gl.<span class="hljs-property">FLOAT</span>,<span class="hljs-literal">false</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>    gl.<span class="hljs-title function_">enableVertexAttribArray</span>(shaderInfo.<span class="hljs-property">attribLocations</span>.<span class="hljs-property">vertexPosition</span>)<br><br>    <span class="hljs-comment">//Bind Color</span><br>    gl.<span class="hljs-title function_">bindBuffer</span>(gl.<span class="hljs-property">ARRAY_BUFFER</span>,buf.<span class="hljs-property">cb</span>)<br>    gl.<span class="hljs-title function_">vertexAttribPointer</span>(shaderInfo.<span class="hljs-property">attribLocations</span>.<span class="hljs-property">vertexColor</span>,<span class="hljs-number">4</span>,gl.<span class="hljs-property">FLOAT</span>,<span class="hljs-literal">false</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>    gl.<span class="hljs-title function_">enableVertexAttribArray</span>(shaderInfo.<span class="hljs-property">attribLocations</span>.<span class="hljs-property">vertexColor</span>)<br><br>    <span class="hljs-comment">//If UseTex</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">usingTex</span>)&#123;<br>        gl.<span class="hljs-title function_">bindBuffer</span>(gl.<span class="hljs-property">ARRAY_BUFFER</span>,buf.<span class="hljs-property">tb</span>)<br>        gl.<span class="hljs-title function_">vertexAttribPointer</span>(shaderInfo.<span class="hljs-property">attribLocations</span>.<span class="hljs-property">vertexTexture</span>,<span class="hljs-number">2</span>,gl.<span class="hljs-property">FLOAT</span>,<span class="hljs-literal">false</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>        gl.<span class="hljs-title function_">enableVertexAttribArray</span>(shaderInfo.<span class="hljs-property">attribLocations</span>.<span class="hljs-property">vertexTexture</span>)<br>    &#125;<br>    <br><br>    gl.<span class="hljs-title function_">useProgram</span>(shaderInfo.<span class="hljs-property">program</span>)<br>    gl.<span class="hljs-title function_">uniformMatrix4fv</span>(<br>        shaderInfo.<span class="hljs-property">uniformLocations</span>.<span class="hljs-property">projectionMatrix</span>,<br>        <span class="hljs-literal">false</span>,<br>        projectionMatrix<br>    )<br>    gl.<span class="hljs-title function_">uniformMatrix4fv</span>(<br>        shaderInfo.<span class="hljs-property">uniformLocations</span>.<span class="hljs-property">modelViewMatrix</span>,<br>        <span class="hljs-literal">false</span>,<br>        modelViewMat<br>    )<br>    gl.<span class="hljs-title function_">uniform3fv</span>(<br>        shaderInfo.<span class="hljs-property">uniformLocations</span>.<span class="hljs-property">ambientLight</span>,<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">ambientLight</span>.<span class="hljs-property">light</span>.<span class="hljs-title function_">getGLMatVec3</span>()<br>    )<br>    gl.<span class="hljs-title function_">activeTexture</span>(gl.<span class="hljs-property">TEXTURE0</span>)<br>    <span class="hljs-keyword">if</span>(texture!=<span class="hljs-literal">null</span>)&#123;<br>        texture.<span class="hljs-title function_">disableMips</span>()<br>        texture.<span class="hljs-title function_">start</span>()<br>    &#125;<br>    gl.<span class="hljs-title function_">uniform1i</span>(shaderInfo.<span class="hljs-property">uniformLocations</span>.<span class="hljs-property">usingTex</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">usingTex</span>)<br>    gl.<span class="hljs-title function_">uniform1i</span>(shaderInfo.<span class="hljs-property">uniformLocations</span>.<span class="hljs-property">sampler</span>,<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span>(fbtex!=<span class="hljs-literal">null</span>)&#123;<br>        fbtex.<span class="hljs-title function_">end</span>()<br>    &#125;<br>    gl.<span class="hljs-title function_">drawArrays</span>(gl.<span class="hljs-property">TRIANGLES</span>,<span class="hljs-number">0</span>,buf.<span class="hljs-property">vnum</span>)<br>    <span class="hljs-keyword">if</span>(texture!=<span class="hljs-literal">null</span>)&#123;<br>        texture.<span class="hljs-title function_">end</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​对于渲染至纹理的部分，使用<code>renderToTexture</code>封装。其基本流程是通过FrameBuffer和Texture进行绑定，将渲染的结果重定向到FrameBuffer绑定的Texture对象上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Javascript Code: render/WGLScene.js</span><br><span class="hljs-title function_">renderToTexture</span>(<span class="hljs-params">shaderInfo,camera,texture</span>)&#123;<br>    <span class="hljs-keyword">let</span> gl = <span class="hljs-variable language_">this</span>.<span class="hljs-property">gl</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fb</span>.<span class="hljs-title function_">start</span>()<br>    texture.<span class="hljs-title function_">start</span>()<br>    gl.<span class="hljs-title function_">viewport</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,texture.<span class="hljs-title function_">getW</span>(),texture.<span class="hljs-title function_">getH</span>())<br>    gl.<span class="hljs-title function_">clearColor</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>    gl.<span class="hljs-title function_">clear</span>(gl.<span class="hljs-property">COLOR_BUFFER_BIT</span>|gl.<span class="hljs-property">DEPTH_BUFFER_BIT</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">renderInternal</span>(shaderInfo,camera,<span class="hljs-literal">null</span>,texture)<br>    texture.<span class="hljs-title function_">end</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fb</span>.<span class="hljs-title function_">end</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>着色器基类和光栅着色器</strong> 着色器基类位于项目的<code>shader/ShaderBase.js</code>文件中，用于提供一个包含顶点着色器（Vertex Shader）和片段着色器（Fragment Shader）的接口。光线追踪、光子映射和光栅渲染三个部分的着色器均继承自着色器基类。光栅着色器用于将光线追踪渲染到纹理上的结果在一个面片上进行渲染，位于项目的<code>shader/TrivialShader.js</code>文件当中。其顶点着色器接收模型变换矩阵（<code>uModelViewMatrix</code>）、投影矩阵（<code>uProjectionMatrix</code>）和环境光照（<code>uAmbientLight</code>），并且向片段着色器输出颜色（<code>vColor</code>）、位置（<code>vPosition</code>）、环境光照信息（<code>vAmbientLight</code>）和顶点信息（<code>vTextureCoord</code>）。顶点着色器主要是对顶点位置根据矩阵进行变换。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//GLSL Shader Code: shader/ShaderBase.js (VertexShader)</span><br><span class="hljs-keyword">attribute</span> <span class="hljs-type">vec4</span> aVertexPosition;<br><span class="hljs-keyword">attribute</span> <span class="hljs-type">vec4</span> aVertexColor;<br><span class="hljs-keyword">attribute</span> <span class="hljs-type">vec2</span> aTextureCoord;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> uModelViewMatrix;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> uProjectionMatrix;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> uAmbientLight;<br><br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">lowp</span> <span class="hljs-type">vec4</span> vColor;<br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec4</span> vPosition;<br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec3</span> vAmbientLight;<br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec2</span> vTextureCoord;<br><br><span class="hljs-type">void</span> main() &#123;<br>  <span class="hljs-built_in">gl_Position</span> = uProjectionMatrix * uModelViewMatrix * aVertexPosition;<br>  vColor = aVertexColor;<br>  vAmbientLight = uAmbientLight;<br>  vTextureCoord = aTextureCoord;<br>  vPosition = aVertexPosition;<br>&#125;<br></code></pre></td></tr></table></figure><p>​片段着色器则用于颜色确定</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs GLSL"><span class="hljs-comment">//GLSL Shader Code: shader/ShaderBase.js (FragmentShader)</span><br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">lowp</span> <span class="hljs-type">vec4</span> vColor;<br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec4</span> vPosition;<br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec3</span> vAmbientLight;<br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec2</span> vTextureCoord;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">int</span> uUsingTex;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> uSampler;<br><span class="hljs-type">int</span> temp;<br><span class="hljs-type">void</span> main() &#123;<br>    <span class="hljs-keyword">highp</span> <span class="hljs-type">vec4</span> ret;<br>    <span class="hljs-keyword">if</span>(uUsingTex==<span class="hljs-number">0</span>)&#123;<br>        ret = <span class="hljs-type">vec4</span>(vColor.xyz * vAmbientLight,vColor.w);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">highp</span> <span class="hljs-type">vec4</span> tex = <span class="hljs-built_in">texture2D</span>(uSampler,<span class="hljs-type">vec2</span>(vTextureCoord.s,vTextureCoord.t));<br>        ret = tex;<br>        <br>    &#125;<br>    ret = ret * <span class="hljs-type">vec4</span>(vAmbientLight,<span class="hljs-number">1.0</span>);<br>    <span class="hljs-built_in">gl_FragColor</span> = ret;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-Ping-Pong-缓冲的实现"><a href="#1-2-Ping-Pong-缓冲的实现" class="headerlink" title="1.2 Ping Pong 缓冲的实现"></a>1.2 Ping Pong 缓冲的实现</h4><p>​为了能够实时地观察到渲染的结果，此处利用WebGL的FrameBuffer实现了Ping Pong缓冲机制。一次计算的时候将上一次光想追踪计算出的结果（Texture A）渲染出来，而当前光线追踪则将计算的结果写入到另一个地方（Texture B）中。当一次计算完成后，将Texture A和Texture B 进行交换。</p><p>​为了将Ping Pong和蒙特卡洛积分进行结合，程序向片段着色器传入一个值uSample表示已有的采样数量，并将已经渲染出的结果（Texture A）同样传入片段着色器中。最终的FragmentColor由Texture A（权重为uSample）和本次的光线追踪计算结果（权重为1）加权平均产生。这部分通过WGLFrameBuffer进行实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Javascript Code: render/WGLFramebuffer.js</span><br><span class="hljs-title function_">bindTexturePingPong</span>(<span class="hljs-params">attachment,textureA,textureB</span>)&#123;<br>    <span class="hljs-keyword">let</span> gl = <span class="hljs-variable language_">this</span>.<span class="hljs-property">gl</span><br>    gl.<span class="hljs-title function_">bindFramebuffer</span>(gl.<span class="hljs-property">FRAMEBUFFER</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">fb</span>)<br>    gl.<span class="hljs-title function_">bindTexture</span>(gl.<span class="hljs-property">TEXTURE_2D</span>,textureA.<span class="hljs-title function_">getTexture</span>())<br>    gl.<span class="hljs-title function_">framebufferTexture2D</span>(gl.<span class="hljs-property">FRAMEBUFFER</span>, attachment,gl.<span class="hljs-property">TEXTURE_2D</span>, textureB.<span class="hljs-title function_">getTexture</span>(), <span class="hljs-number">0</span>)<br>    gl.<span class="hljs-title function_">bindTexture</span>(gl.<span class="hljs-property">TEXTURE_2D</span>,<span class="hljs-literal">null</span>)<br>    gl.<span class="hljs-title function_">bindFramebuffer</span>(gl.<span class="hljs-property">FRAMEBUFFER</span>,<span class="hljs-literal">null</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>而在光线追踪场景渲染时，只需要调用<code>bindTexturePingPong</code>就可以很容易地实现Texture的切换。代码中的省略号为省略与该部分无关的代码，不代表源代码此处是省略号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Javascript Code: path-tracing/raytracing/RTScene.js </span><br><span class="hljs-title function_">render</span>(<span class="hljs-params">firstRender=<span class="hljs-literal">true</span>,doClear = <span class="hljs-literal">false</span></span>)&#123;<br>        <span class="hljs-keyword">let</span> gl = <span class="hljs-variable language_">this</span>.<span class="hljs-property">gl</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">frameBuffer</span>.<span class="hljs-title function_">bindTexturePingPong</span>(gl.<span class="hljs-property">COLOR_ATTACHMENT0</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">renderOutput</span>[<span class="hljs-number">0</span>],<span class="hljs-variable language_">this</span>.<span class="hljs-property">renderOutput</span>[<span class="hljs-number">1</span>])<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">frameBuffer</span>.<span class="hljs-title function_">start</span>()<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-光线追踪-路径追踪算法"><a href="#2-光线追踪-路径追踪算法" class="headerlink" title="2. 光线追踪(路径追踪算法)"></a>2. 光线追踪(路径追踪算法)</h3><h4 id="2-1-主体框架"><a href="#2-1-主体框架" class="headerlink" title="2.1 主体框架"></a>2.1 主体框架</h4><h5 id="2-1-1-整体框架"><a href="#2-1-1-整体框架" class="headerlink" title="2.1.1 整体框架"></a>2.1.1 整体框架</h5><p>​WebGL常用于光栅渲染，要利用WebGL进行光线追踪渲染无法通过常规的途径实现。在Web端通常有两个选择途径，一个是使用JavaScript脚本进行渲染。该方法在JavaScript脚本中计算光线追踪的渲染结果，然后将光线追踪的结果通过uniform传入片段着色器进行着色，该方法调试简单，但计算过程依赖于CPU，且Web的客户端脚本不适合执行高性能的运算操作，因此我们并没有采用此方法。另一种是将光线追踪的内容写入着色器中，虽然该方法调试开销极大，但该方法能够最大限度地利用GPU的运算性能，因此我们选择了此方法作为此项目的渲染方法。</p><p>​通常着色器的代码是不变的，在使用着色器时，只需要将值通过attribute（高版本的GLSL为in关键字）或者uniform传入即可。但也可以使用动态着色器生成的思路，后者在调试上相对更加容易，且能够减小代码冗余。Niklas F和Daniel W也就实时渲染中的动态代码生成进行研究<sup>[2]</sup>。在本项目中我们综合了两种方案，对于常量信息使用传统的uniform传值方案，对于复杂的，且容易产生冗余和难以调试的内容，我们使用后一种方案。</p><p>​同样，为了使得代码具有可扩展性和可维护性，修改场景只需要增加或修改一两行的JavaScript代码，而不是对GLSL代码进行大幅度修改，我们同样使用了面向对象的思想将光线追踪中的一些概念进行封装，封装后的对象位于文件<code>path-tracing/raytracing</code>文件夹中。主要的文件结构如下所述：</p><ul><li><strong>RTObserver</strong>：该类封装光线追踪中的相机对象，用于处理光线追踪当中的投影变换和模型视图变换。具体将在</li><li><strong>RTScene</strong>：该类用于存放场景中的几何体，并根据其中的相机对象和着色器对象，将光追的结果渲染到一个矩形区域上（渲染区域和Texture绑定）</li><li><strong>RTShader</strong>：该类继承自着色器基类ShaderBase，主要处理两个部分，顶点着色器负责处理矩形区域的顶点，以及根据RTObserver中传入的变换矩阵，将四个顶点上的光线方向向量进行确定，光线方向将传入片段着色器中；片段着色器对传入的四个方向向量进行插值，得到每一个像素点的光线方向，之后进行光线碰撞和追踪。</li><li><strong>RTShaderUtil</strong>：该类用于动态生成和组合着色器的代码。</li><li><strong>RTShaderVariableMap</strong>：该类用于建立uniform变量和其值之间的映射，主要目的是进行封装来化简操作。避免每一次都调用<code>getUniformLocation</code>和<code>uniform*v</code>等函数，便于进行代码调试和维护</li><li><strong>Preset 文件夹</strong>：该文件夹存放预设的场景<ul><li><strong>RTGlassTest</strong>： 为一个玻璃球和一个金属球的室内场景，玻璃折射率为1.5</li><li><strong>RTLiquidTest</strong>：为一个带水面的两个粗糙小球的半封闭（顶部开放）的场景，水为蓝色</li><li><strong>RTSceneWithGeometry</strong>：该场景为一个室内具有很多个不同材质小球的场景</li><li><strong>RTSceneWithGeometryOutdoors</strong>：该场景为室外具有很多不同材质小球的场景</li></ul></li><li><strong>Component 文件夹</strong>：该文件夹存放与光追相关的组件内容<ul><li><strong>RTAmbientLight</strong>：环境光照，为在每一次光线反射时附加计算的光照信息。</li><li><strong>RTMaterial</strong>：材质信息，可以附加到几何体上，包括材质颜色、发光颜色、折射率、材质类型等。一共提供七种材质类型，为该类下的静态常量（<code>ABSORBED</code>为完全吸收、<code>DIFFUSE</code>为理想漫反射、<code>SPECULAR</code>为理想镜面反射、<code>REFRACTION</code>为理想折射、<code>METAL</code>为金属材质、<code>MOSSY</code>为粗糙玻璃表面、<code>WATER</code>为水面）</li><li><strong>RTPointLight</strong>：点光源，该类为学习光线追踪算法时，实现Whitted-Style光线追踪的残留类，在路径追踪算法中，该光源不使用。</li><li><strong>RTSkyLight</strong>：天空颜色，当一个光线无法触碰到任何的物体时，其返回天空颜色</li><li><strong>RTPlane</strong>：几何体，三角形平面。</li><li><strong>RTSphere</strong>：几何体，球。</li><li><strong>RTTetrahedron</strong>：组合的几何体，四面体。由四个RTPlane组成。</li><li><strong>RTWaterSurface</strong>：几何体，无限水面。</li></ul></li></ul><h5 id="2-1-2-渲染至纹理对象和Ping-Pong的实现"><a href="#2-1-2-渲染至纹理对象和Ping-Pong的实现" class="headerlink" title="2.1.2 渲染至纹理对象和Ping Pong的实现"></a>2.1.2 渲染至纹理对象和Ping Pong的实现</h5><p>​渲染过程由光追的场景对象<code>RTScene</code>完成，其主要过程是先调用之前第一节中封装过的<code>WGLFrameBuffer</code>和<code>WGLTexture</code>中的函数，完成Ping Pong的切换以及帧缓冲和纹理对象的绑定，该步骤完成后，一切渲染操作将输出到和当前绑定的帧缓冲所绑定的纹理上。之后和普通的渲染过程没什么差别，即设定视窗（<code>glViewPort</code>）、清屏（<code>glClearColor</code>）、设定Uniform（2.1.1中<code>RTShaderVariableMap</code>封装的方法）、绑定顶点（即把矩形的四个顶点进行绑定，并启用其传入着色器的选项）。最后就是很简单的画图（<code>glDrawArrays</code>）。绘制完成后，解除帧缓冲和纹理的绑定，然后Ping Pong 翻转纹理对象，使得当前完成渲染的纹理能够贝使用。该过程位于<code>RTScene</code>的<code>render</code>函数下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Javascript Code: path-tracing/raytracing/RTScene.js </span><br><span class="hljs-title function_">render</span>(<span class="hljs-params">firstRender=<span class="hljs-literal">true</span>,doClear = <span class="hljs-literal">false</span></span>)&#123;<br>    <span class="hljs-keyword">let</span> gl = <span class="hljs-variable language_">this</span>.<span class="hljs-property">gl</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frameBuffer</span>.<span class="hljs-title function_">bindTexturePingPong</span>(gl.<span class="hljs-property">COLOR_ATTACHMENT0</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">renderOutput</span>[<span class="hljs-number">0</span>],<span class="hljs-variable language_">this</span>.<span class="hljs-property">renderOutput</span>[<span class="hljs-number">1</span>])<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frameBuffer</span>.<span class="hljs-title function_">start</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderOutput</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">start</span>()<br>    gl.<span class="hljs-title function_">viewport</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRenderOutput</span>().<span class="hljs-title function_">getW</span>(),<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRenderOutput</span>().<span class="hljs-title function_">getH</span>())<br>    gl.<span class="hljs-title function_">clearColor</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">if</span>(firstRender)&#123;<br>        gl.<span class="hljs-title function_">useProgram</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">compiledShader</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">shaderVar</span>.<span class="hljs-title function_">bindShaderVarible</span>(gl,<span class="hljs-variable language_">this</span>.<span class="hljs-property">compiledShader</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateUniform</span>()<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loadAlternativeTexture</span>()<br>        gl.<span class="hljs-title function_">bindBuffer</span>(gl.<span class="hljs-property">ARRAY_BUFFER</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">sheetcb</span>)<br>        gl.<span class="hljs-title function_">vertexAttribPointer</span>(gl.<span class="hljs-title function_">getAttribLocation</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">compiledShader</span>,<span class="hljs-string">&#x27;aVertexColor&#x27;</span>),<span class="hljs-number">4</span>,gl.<span class="hljs-property">FLOAT</span>,<span class="hljs-literal">false</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>        gl.<span class="hljs-title function_">enableVertexAttribArray</span>(gl.<span class="hljs-title function_">getAttribLocation</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">compiledShader</span>,<span class="hljs-string">&#x27;aVertexColor&#x27;</span>))<br><br>        gl.<span class="hljs-title function_">bindBuffer</span>(gl.<span class="hljs-property">ARRAY_BUFFER</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">sheetvb</span>)<br>        gl.<span class="hljs-title function_">vertexAttribPointer</span>(gl.<span class="hljs-title function_">getAttribLocation</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">compiledShader</span>,<span class="hljs-string">&#x27;aVertexPosition&#x27;</span>),<span class="hljs-number">3</span>,gl.<span class="hljs-property">FLOAT</span>,<span class="hljs-literal">false</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>        gl.<span class="hljs-title function_">enableVertexAttribArray</span>(gl.<span class="hljs-title function_">getAttribLocation</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">compiledShader</span>,<span class="hljs-string">&#x27;aVertexPosition&#x27;</span>))<br>    &#125;<br><br>    gl.<span class="hljs-title function_">drawArrays</span>(gl.<span class="hljs-property">TRIANGLE_STRIP</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sampleCount</span>++;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderOutput</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">end</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frameBuffer</span>.<span class="hljs-title function_">end</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderOutput</span>.<span class="hljs-title function_">reverse</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-坐标系的建立和光线的发射"><a href="#2-2-坐标系的建立和光线的发射" class="headerlink" title="2.2 坐标系的建立和光线的发射"></a>2.2 坐标系的建立和光线的发射</h4><p>​对于场景中的物体坐标$V$，设投影矩阵为$P$，模型矩阵为$M$。经过变换后的坐标应该为$VPM$，可以对场景中的所有物体的坐标都应用上述的变换，得到最终的坐标。但上述开销相对较大。我们可以对光线和视点采取$P$和$M$的逆变换$M^{-1}P^{-1}$。这个即为光追场景中坐标系建立的初步思路。</p><p>​在光追相机对象<code>RTObserver</code>中，我们重新封装了第一章中提及的<code>Camera</code>对象，对于<code>getRay</code>为获取视点处到(x,y,z)的视线方向，用于发射光线，在此处我们使用齐次坐标，应用上述的逆变换调整光线方向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Javascript Code: path-tracing/raytracing/RTObserver.js </span><br><span class="hljs-title function_">getRay</span>(<span class="hljs-params">x,y,z=<span class="hljs-number">0</span></span>)&#123;<br>    <span class="hljs-keyword">let</span> orgvec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vec</span>(x,y,z)<br>    <span class="hljs-keyword">let</span> orgvecm = mat4.<span class="hljs-title function_">create</span>()<br>    mat4.<span class="hljs-title function_">set</span>(orgvecm,<br>             orgvec.<span class="hljs-property">x</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>             orgvec.<span class="hljs-property">y</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>             orgvec.<span class="hljs-property">z</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>             <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">let</span> projvecm = mat4.<span class="hljs-title function_">create</span>()<br>    mat4.<span class="hljs-title function_">mul</span>(projvecm,<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getCameraMatrix</span>(),orgvecm)<br>    mat4.<span class="hljs-title function_">invert</span>(projvecm,projvecm)<br>    <span class="hljs-keyword">let</span> projvec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vec</span>(projvecm[<span class="hljs-number">0</span>]/projvecm[<span class="hljs-number">12</span>],projvecm[<span class="hljs-number">4</span>]/projvecm[<span class="hljs-number">12</span>],projvecm[<span class="hljs-number">8</span>]/projvecm[<span class="hljs-number">12</span>])<br>    <span class="hljs-keyword">let</span> ray = projvec.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getEye</span>().<span class="hljs-title function_">neg</span>())<br>    <span class="hljs-keyword">return</span> ray.<span class="hljs-title function_">getGLMatVec3</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>​我们将四个方向的光线向量传入到RTShaderVariableMap对象中，便于uniform的实时更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Javascript Code: path-tracing/raytracing/RTObserver.js </span><br><span class="hljs-title function_">prepareShaderMap</span>(<span class="hljs-params">shaderMap</span>)&#123;<br>    shaderMap.<span class="hljs-title function_">insert</span>(<span class="hljs-string">&#x27;raylt&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRay</span>(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">dist</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">screenPos</span>.<span class="hljs-property">z</span>),<span class="hljs-title class_">RTShaderVariableMap</span>.<span class="hljs-property">VEC3</span>)<br>    shaderMap.<span class="hljs-title function_">insert</span>(<span class="hljs-string">&#x27;raylb&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRay</span>(-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">dist</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">screenPos</span>.<span class="hljs-property">z</span>),<span class="hljs-title class_">RTShaderVariableMap</span>.<span class="hljs-property">VEC3</span>)<br>    shaderMap.<span class="hljs-title function_">insert</span>(<span class="hljs-string">&#x27;rayrb&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRay</span>(<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">dist</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">screenPos</span>.<span class="hljs-property">z</span>),<span class="hljs-title class_">RTShaderVariableMap</span>.<span class="hljs-property">VEC3</span>)<br>    shaderMap.<span class="hljs-title function_">insert</span>(<span class="hljs-string">&#x27;rayrt&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRay</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">dist</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">screenPos</span>.<span class="hljs-property">z</span>),<span class="hljs-title class_">RTShaderVariableMap</span>.<span class="hljs-property">VEC3</span>)<br>    shaderMap.<span class="hljs-title function_">insert</span>(<span class="hljs-string">&#x27;eye&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getEye</span>().<span class="hljs-title function_">getGLMatVec3</span>(),<span class="hljs-title class_">RTShaderVariableMap</span>.<span class="hljs-property">VEC3</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>​对于顶点着色器而言，由于渲染的是一张矩形的图片，因此不需要进行任何的坐标变换。只需要对上面传入的向矩形四个定点发射的光线方向向量进行插值，并且将其传入到片段着色器当中即可。因此顶点着色器不需要非常复杂，只需要一个mix插值函数即可。对于光追的着色器，我们使用了GLSL 300 ES版本的着色器语言。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs GLSL"><span class="hljs-meta">#version 300 es</span><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> aVertexPosition;<br><span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> aVertexColor;<br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aVertexTex;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> uModelViewMatrix;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> uProjectionMatrix;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> raylb;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> raylt;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> rayrb;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> rayrt;<br><br><span class="hljs-keyword">out</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec3</span> ray;<br><span class="hljs-keyword">out</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec4</span> color;<br><span class="hljs-keyword">out</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec2</span> tex;<br><span class="hljs-type">void</span> main() &#123;<br>    <span class="hljs-type">float</span> yp = aVertexPosition.y*<span class="hljs-number">0.5</span>+<span class="hljs-number">0.5</span>;<br>    <span class="hljs-built_in">gl_Position</span> = aVertexPosition;<br>    ray = <span class="hljs-built_in">mix</span>(<span class="hljs-built_in">mix</span>(raylb,raylt,yp),<span class="hljs-built_in">mix</span>(rayrb,rayrt,yp),aVertexPosition.x*<span class="hljs-number">0.5</span>+<span class="hljs-number">0.5</span>);<br>    color = aVertexColor;<br>    tex = aVertexTex;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-光线和物体的碰撞判定与片段着色器的动态生成"><a href="#2-3-光线和物体的碰撞判定与片段着色器的动态生成" class="headerlink" title="2.3 光线和物体的碰撞判定与片段着色器的动态生成"></a>2.3 光线和物体的碰撞判定与片段着色器的动态生成</h4><p>​在2.2完成后，片段着色器拿到的ray的方向就可以直接使用了。在此之前，还需要对光线和物体的碰撞判断进行处理。此节中将阐述球体和三角平面的碰撞判断。对于水面的碰撞判断，将在2.7节中阐述。</p><h5 id="2-3-1-光线和球体的相交判定"><a href="#2-3-1-光线和球体的相交判定" class="headerlink" title="2.3.1 光线和球体的相交判定"></a>2.3.1 光线和球体的相交判定</h5><p>​在项目中光线使用向量$\vec{L}&#x3D;\vec{O}+t\vec{D}$进行表示，其中$\vec{D}$是单位向量。对于一个三维球体，其可以使用方程$|\vec{X}-\vec{C}|&#x3D;R$表示，其中$\vec{X}$是球上任意一点，$\vec{C}$是圆心。光线和球的相交判定，即判断$|\vec{O}+t\vec{D}-\vec{C}|&#x3D;R$是否有解。因此，需要解一元二次方程组。</p><p>​设$\vec{P}&#x3D;\vec{O}-\vec{C}$，则上述方程可转换为$(t^2\vec{D}^2-2t\vec{D}\vec{P}+\vec{P}^2)&#x3D;R^2$是否有解。此时可以确定一元二次方程的系数$a&#x3D;\vec{D}^2,b&#x3D;-2\vec{D}\vec{P},c&#x3D;\vec{P}^2$，据此得到判别式$\Delta&#x3D;b^2-4ac$。若判别式值小于等于0，直接舍弃（和球面相切的可以不必判断）。否则得到方程的两个根$x_1,x_2&#x3D;(-b+\sqrt{\Delta})&#x2F;(2a)$，此时选取两根中为正值的最小者（如果都为负值，直接返回其中一个，负值在后续会被舍弃，此处不需要特判），作为相交结果。该部分的代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs GLSL"><span class="hljs-comment">//GLSL Shader Code: path-tracing/raytracing/RTShaderUtil.js (FragmentShader)</span><br><span class="hljs-type">float</span> fRaySphereIntersection(sRay r,sSphere s)&#123;<br>    <span class="hljs-type">vec3</span> p = r.origin-s.c;<br>    <span class="hljs-type">float</span> a = <span class="hljs-built_in">dot</span>(r.direction,r.direction);<br>    <span class="hljs-type">float</span> b = <span class="hljs-number">2.0</span>*(<span class="hljs-built_in">dot</span>(r.direction,p));<br>    <span class="hljs-type">float</span> delta = b*b<span class="hljs-number">-4.0</span>*a*(<span class="hljs-built_in">dot</span>(p,p)-s.r*s.r);<br>    <span class="hljs-keyword">if</span>(delta&lt;<span class="hljs-number">1e-10</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1.0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">float</span> sdelta = <span class="hljs-built_in">sqrt</span>(delta);<br>        <span class="hljs-type">float</span> t1 = (-b+sdelta)/(<span class="hljs-number">2.0</span>*a);<br>        <span class="hljs-type">float</span> t2 = (-b-sdelta)/(<span class="hljs-number">2.0</span>*a);<br>        <span class="hljs-keyword">if</span>(t1&gt;<span class="hljs-number">0.0</span>&amp;&amp;t2&gt;<span class="hljs-number">0.0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(t1&gt;t2)&#123;<br>                <span class="hljs-keyword">return</span> t2;<br>            &#125;<br>            <span class="hljs-keyword">return</span> t1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(t1&gt;<span class="hljs-number">0.0</span>&amp;&amp;t2&lt;<span class="hljs-number">0.0</span>)&#123;<br>            <span class="hljs-keyword">return</span> t1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> t2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​若要得到交点坐标，直接将该函数的返回值按照$\vec{L}&#x3D;\vec{O}+t\vec{D}$进行计算即可。另外上述使用$eps&#x3D;1e-10$来防止浮点误差，该方法在后续也会使用。</p><h5 id="2-3-2-光线和平面的相交判定"><a href="#2-3-2-光线和平面的相交判定" class="headerlink" title="2.3.2 光线和平面的相交判定"></a>2.3.2 光线和平面的相交判定</h5><p>​对于一个平面，可以使用方程$A(x-x_0)+B(y-y_0)+C(z-z_0)&#x3D;0$表示，即$\vec{N}\cdot (\vec{X}-\vec{X_0})&#x3D;0$，因此只需要解方程$\vec{N}(\vec{O}+t\vec{D})&#x3D;\vec{N}\vec{X_0}$即可。该方程移项可得$t\vec{N}\vec{D}&#x3D;\vec{N}\vec{X_0}-\vec{N}\vec{O}$，因此有：<br>$$<br>t&#x3D;\frac{\vec{N}\vec{X_0}-\vec{N}\vec{O}}{\vec{N}\vec{D}}<br>$$<br>​对于$X_0$，可以从三角形的顶点中随机选取一个。因此可以很容易地得到平面和光线相交的判定结果。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs GLSL"><span class="hljs-comment">//GLSL Shader Code: path-tracing/raytracing/RTShaderUtil.js (FragmentShader)</span><br><span class="hljs-type">float</span> fRayPlaneIntersection(sRay r,sPlane p)&#123;<br>    <span class="hljs-type">vec3</span> n = fPlaneNorm(p);<br>    <span class="hljs-type">vec3</span> di = r.direction;<br>    <span class="hljs-type">vec3</span> or = r.origin;<br>    <span class="hljs-type">vec3</span> a = p.y;<br>    <span class="hljs-type">float</span> rd = <span class="hljs-built_in">dot</span>(n,di);<br>    <span class="hljs-type">float</span> rn = <span class="hljs-built_in">dot</span>(n,a-or);<br>    <span class="hljs-keyword">return</span> rn/rd;<br>&#125;<br></code></pre></td></tr></table></figure><p>​之后需要判断该交点是否在三角形区域内。此处利用三角形的面积进行判断，对于三角形内部一点$P$，其在三角形内部需要满足的条件为：<br>$$<br>S_{\Delta ABP}+S_{\Delta BCP}+S_{\Delta CAP}&#x3D;S_{\Delta ABC}<br>$$<br>​根据向量叉乘计算面积，上式可以重新写为：<br>$$<br>|\vec{PA}\times\vec{PB}|+|\vec{PC}\times\vec{PB}|+|\vec{PA}\times\vec{PC}|&#x3D;|\vec{AB}\times\vec{AC}|<br>$$<br>​然后就可以得到点在三角形内的判别式。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs GLSL"><span class="hljs-comment">//GLSL Shader Code: path-tracing/raytracing/RTShaderUtil.js (FragmentShader)</span><br><span class="hljs-type">bool</span> fInsidePlane(sPlane p,<span class="hljs-type">vec3</span> v)&#123;<br>    <span class="hljs-type">vec3</span> v1 = p.x - v;<br>    <span class="hljs-type">vec3</span> v2 = p.y - v;<br>    <span class="hljs-type">vec3</span> v3 = p.z - v;<br>    <span class="hljs-type">float</span> s1 = <span class="hljs-built_in">length</span>(<span class="hljs-built_in">cross</span>(v1,v2));<br>    <span class="hljs-type">float</span> s2 = <span class="hljs-built_in">length</span>(<span class="hljs-built_in">cross</span>(v2,v3));<br>    <span class="hljs-type">float</span> s3 = <span class="hljs-built_in">length</span>(<span class="hljs-built_in">cross</span>(v3,v1));<br>    <span class="hljs-type">float</span> s0 = <span class="hljs-built_in">length</span>(<span class="hljs-built_in">cross</span>(p.y-p.x,p.z-p.x));<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">abs</span>(s0)-<span class="hljs-built_in">abs</span>(s1)-<span class="hljs-built_in">abs</span>(s2)-<span class="hljs-built_in">abs</span>(s3))&lt;<span class="hljs-number">1e-5</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p><h5 id="2-3-3-记录最近的碰撞点及动态着色器代码生成"><a href="#2-3-3-记录最近的碰撞点及动态着色器代码生成" class="headerlink" title="2.3.3 记录最近的碰撞点及动态着色器代码生成"></a>2.3.3 记录最近的碰撞点及动态着色器代码生成</h5><p>​光线追踪要求记录光线最近的碰撞信息，因此我们实现了一个函数<code>fRayCollision</code>来进行光线和所有物体的碰撞判断。在该函数中，维护一个最近的碰撞距离$t$，只有物体和光线碰撞距离更小时，该值才会更新。同时碰撞的法线（<code>colnorm</code>）、辐射颜色（<code>emicolor</code>）、材质颜色（<code>matcolor</code>）、是否碰撞（<code>collided</code>）、折射率（<code>refra</code>）、碰撞点（<code>colvex</code>，<code>colp</code>）等信息也将同步维护，最近的碰撞结果将放入结构体<code>sRayCollisionResult</code>返回调用者。其中该结构体的定义如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//GLSL Shader Code: path-tracing/raytracing/RTShaderUtil.js (FragmentShader)</span><br>struct sRayCollisionResult&#123;<br>    <span class="hljs-type">vec3</span> colvex;<br>    <span class="hljs-type">vec3</span> colnorm;<br>    <span class="hljs-type">bool</span> collided;<br>    <span class="hljs-type">vec4</span> emissionColor;<br>    <span class="hljs-type">vec4</span> materialColor;<br>    <span class="hljs-type">int</span> hitType;<br>    <span class="hljs-type">float</span> refra;<br>&#125;;<br></code></pre></td></tr></table></figure><p>​对于如何遍历所有物体，此处采用动态代码生成的形式。每一个几何体生成一段自身的碰撞代码，动态地放入该部分。所有几何体的JavaScript类都需要实现<code>genShaderIntersection</code>方法，在其中放入该几何体的碰撞判断逻辑。在几何体被放入场景对象RTScene 后，<code>genIntersectionJudge</code>方法负责将所有几何体的碰撞判断逻辑整合为一个顺序执行的代码，在生成片段着色器时（RTScene的<code>genFragmentShader</code>），会调用该代码，并将其插入到着色器函数的<code>fRayCollision</code>函数中，下方代码的object处即为代码插入处。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Javascript Code: path-tracing/raytracing/RTShaderUtil.js</span><br><span class="hljs-keyword">static</span> <span class="hljs-title function_">funcDef_RayCollision</span>(<span class="hljs-params">objects=<span class="hljs-string">&quot;&quot;</span></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">            sRayCollisionResult fRayCollision(sRay r)&#123;</span><br><span class="hljs-string">                float t = 1e30;</span><br><span class="hljs-string">                vec3 norm = vec3(0.0,0.0,0.0);</span><br><span class="hljs-string">                vec4 emicolor = vec4(1.0,1.0,1.0,1.0);</span><br><span class="hljs-string">                vec4 matcolor = vec4(0.0,0.0,0.0,1.0);</span><br><span class="hljs-string">                bool collided = false;</span><br><span class="hljs-string">                float tc=1e30;</span><br><span class="hljs-string">                float refra = 1.0;</span><br><span class="hljs-string">                int hitType = 0;</span><br><span class="hljs-string">                bool colc = false;</span><br><span class="hljs-string">                `</span>+objects+<span class="hljs-string">`</span><br><span class="hljs-string">                vec3 colp = fRayPoint(r,t);</span><br><span class="hljs-string">                sRayCollisionResult ret = sRayCollisionResult(colp,norm,collided,emicolor,matcolor,hitType,refra);</span><br><span class="hljs-string">                return ret;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        `</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>​对于三角平面，生成的碰撞检测代码为：（其中<code>uEM</code>，<code>uCL</code>，<code>uRF</code>为材质的uniform，<code>this,material.tp</code>为材质类型，VA~VC为顶点）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Javascript Code: path-tracing/raytracing/components/geometry/RTPlane.js</span><br><span class="hljs-title function_">genObject</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> ret = <span class="hljs-string">``</span><br>        ret = <span class="hljs-string">&#x27;sPlane(&#x27;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>+<span class="hljs-string">&quot;_VA&quot;</span>+<span class="hljs-string">&#x27;,&#x27;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>+<span class="hljs-string">&quot;_VB&quot;</span>+<span class="hljs-string">&#x27;,&#x27;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>+<span class="hljs-string">&quot;_VC&quot;</span>+<span class="hljs-string">&#x27;,&#x27;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>+<span class="hljs-string">&quot;_EM&quot;</span>+<span class="hljs-string">&quot;,&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>+<span class="hljs-string">&quot;_CL)&quot;</span><br>        <span class="hljs-keyword">return</span> ret<br>    &#125;<br><span class="hljs-title function_">genShaderIntersection</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">                if(true)&#123;</span><br><span class="hljs-string">                    sPlane pl = `</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">genObject</span>()+<span class="hljs-string">`;</span><br><span class="hljs-string">                    tc = fRayPlaneIntersection(r,pl);</span><br><span class="hljs-string">                    if(tc&gt;0.0)&#123;</span><br><span class="hljs-string">                        vec3 ip = fRayPoint(r,tc);</span><br><span class="hljs-string">                        if(fInsidePlane(pl,ip))&#123;</span><br><span class="hljs-string">                            if(tc&lt;t)&#123;</span><br><span class="hljs-string">                                t=tc;</span><br><span class="hljs-string">                                norm = fPlaneNorm(pl);</span><br><span class="hljs-string">                                emicolor = vec4(`</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">uEM</span>+<span class="hljs-string">`);</span><br><span class="hljs-string">                                matcolor = vec4(`</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">uCL</span>+<span class="hljs-string">`);</span><br><span class="hljs-string">                                hitType = `</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">material</span>.<span class="hljs-property">tp</span>+<span class="hljs-string">`;</span><br><span class="hljs-string">                                refra = `</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">uRF</span>+<span class="hljs-string">`;</span><br><span class="hljs-string">                                collided=true;</span><br><span class="hljs-string">                            &#125;</span><br><span class="hljs-string">                        &#125;</span><br><span class="hljs-string">                    &#125;</span><br><span class="hljs-string">                &#125;</span><br><span class="hljs-string">            </span><br><span class="hljs-string">        `</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>​对于球体部分，代码为：（其中VC为圆心，RA为半径，其他同上）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Javascript Code: path-tracing/raytracing/components/geometry/RTSphere.js</span><br><span class="hljs-title function_">genObject</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> ret = <span class="hljs-string">``</span><br>        ret = <span class="hljs-string">&#x27;sSphere(&#x27;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>+<span class="hljs-string">&quot;_VC&quot;</span>+<span class="hljs-string">&#x27;,&#x27;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>+<span class="hljs-string">&quot;_RA&quot;</span>+<span class="hljs-string">&#x27;,&#x27;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>+<span class="hljs-string">&quot;_EM&quot;</span>+<span class="hljs-string">&quot;,&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>+<span class="hljs-string">&quot;_CL)&quot;</span><br>        <span class="hljs-keyword">return</span> ret<br>    &#125;<br>    <span class="hljs-title function_">genShaderIntersection</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string"></span><br><span class="hljs-string">                if(true)&#123;</span><br><span class="hljs-string">                    sSphere sp = `</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">genObject</span>()+<span class="hljs-string">`;</span><br><span class="hljs-string">                    tc = fRaySphereIntersection(r,sp);</span><br><span class="hljs-string">                    if(tc&gt;0.0 &amp;&amp; tc&lt;t)&#123;</span><br><span class="hljs-string">                        t=tc;</span><br><span class="hljs-string">                        norm = fRayPoint(r,tc) - `</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>+<span class="hljs-string">&#x27;_VC&#x27;</span>+<span class="hljs-string">`;</span><br><span class="hljs-string">                        emicolor = vec4(`</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">uEM</span>+<span class="hljs-string">`);</span><br><span class="hljs-string">                        matcolor = vec4(`</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">uCL</span>+<span class="hljs-string">`);</span><br><span class="hljs-string">                        hitType = `</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">material</span>.<span class="hljs-property">tp</span>+<span class="hljs-string">`;</span><br><span class="hljs-string">                        refra = `</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">uRF</span>+<span class="hljs-string">`;</span><br><span class="hljs-string">                        collided=true;</span><br><span class="hljs-string">                    &#125;</span><br><span class="hljs-string">                &#125;</span><br><span class="hljs-string">        `</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>​两个代码中的<code>if(true)</code>用于隔离局部变量，使得一个局部变量能够被多次声明，且互不影响。</p><h4 id="2-4-镜面反射、漫反射以及金属材质的实现"><a href="#2-4-镜面反射、漫反射以及金属材质的实现" class="headerlink" title="2.4 镜面反射、漫反射以及金属材质的实现"></a>2.4 镜面反射、漫反射以及金属材质的实现</h4><p>​对于镜面反射，设入射向量为$\vec{I}$，入射点的单位法向量为$\vec{N}$（保持和入射方向的夹角为钝角）。则入射向量在法向量方向上的投影长度为$\vec{I}\vec{N}$，因此可以设修正后的入射向量$\vec{I’}&#x3D;\vec{I}&#x2F;\vec{I}\vec{N}$，而出射向量满足$\vec{O}&#x3D;\vec{I’}+2\vec{N}$，之后对该向量进行单位化就可得到反射向量。因此镜面反射十分简单。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs GLSL"><span class="hljs-comment">//GLSL Shader Code: path-tracing/raytracing/RTShaderUtil.js (FragmentShader)</span><br>sRay fSpecularReflection(sRay inr,<span class="hljs-type">vec3</span> p,<span class="hljs-type">vec3</span> n)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dot</span>(inr.direction,n)&gt;<span class="hljs-number">0.0</span>)&#123;<br>        n = -n;<br>    &#125;<br>    <span class="hljs-type">vec3</span> ox = inr.direction/<span class="hljs-built_in">dot</span>(inr.direction,n)+<span class="hljs-number">2.0</span>*n;<br>    sRay ret = sRay(p,ox/<span class="hljs-built_in">length</span>(ox),inr.inrefra);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>​对于漫反射，在反射后采用在和法向量相同半球方向上（即和法向量内积大于0）随机选取一个反向作为反射方向。漫反射中极其依赖随机数的生成，对于随机数的生成将在2.8节中讨论。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs GLSL"><span class="hljs-comment">//GLSL Shader Code: path-tracing/raytracing/RTShaderUtil.js (FragmentShader)</span><br>sRay fDiffuseReflection(sRay inr,<span class="hljs-type">vec3</span> p,<span class="hljs-type">vec3</span> norm)&#123;<br>    <span class="hljs-type">vec3</span> n = norm;<br>    n = n / <span class="hljs-built_in">length</span>(n);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dot</span>(inr.direction,norm)&gt;<span class="hljs-number">0.0</span>)&#123;<br>        n = -n;<br>    &#125;<br>    <span class="hljs-type">vec3</span> o = uniformlyRandomDirectionNew();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dot</span>(o,n)&lt;<span class="hljs-number">0.0</span>)&#123;<br>        o = -o;<br>    &#125;<br>    sRay rt = sRay(p,o,inr.inrefra);<br>    <span class="hljs-keyword">return</span> rt;<br>&#125;<br></code></pre></td></tr></table></figure><p>​对于金属材质，是理想镜面反射和理想漫反射的一个综合。因此对于镜面反射得到的向量$\vec{O}$，在$\vec{P}+\vec{O}&#x2F;|\vec{O}|$ 处按照漫反射的方法进行随机的方向选取，设此时得到的随机方向为$\vec{D}$，则最终反射方向为$\vec{F}&#x3D;\vec{O}+\vec{D}$。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//GLSL Shader Code: path-tracing/raytracing/RTShaderUtil.js (FragmentShader)</span><br>sRay fGlsryReflection(sRay inr,<span class="hljs-type">vec3</span> p,<span class="hljs-type">vec3</span> norm)&#123;<br>    <span class="hljs-type">vec3</span> n = norm;<br>    n = n / <span class="hljs-built_in">length</span>(n);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dot</span>(inr.direction,norm)&gt;<span class="hljs-number">0.0</span>)&#123;<br>        n = -n;<br>    &#125;<br>    <span class="hljs-type">vec3</span> o = uniformlyRandomDirectionNew();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dot</span>(o,n)&lt;<span class="hljs-number">0.0</span>)&#123;<br>        o = -o;<br>    &#125;<br>    <span class="hljs-type">vec3</span> ox = (inr.direction/<span class="hljs-built_in">dot</span>(inr.direction,n)+<span class="hljs-number">2.0</span>*n)+o;<br>    ox = ox/<span class="hljs-built_in">length</span>(ox);<br>    sRay rt = sRay(p,ox,inr.inrefra);<br>    <span class="hljs-keyword">return</span> rt;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-5-蒙特卡洛积分和迭代采样"><a href="#2-5-蒙特卡洛积分和迭代采样" class="headerlink" title="2.5 蒙特卡洛积分和迭代采样"></a>2.5 蒙特卡洛积分和迭代采样</h4><h5 id="2-5-1-蒙特卡洛积分"><a href="#2-5-1-蒙特卡洛积分" class="headerlink" title="2.5.1 蒙特卡洛积分"></a>2.5.1 蒙特卡洛积分</h5><p>​本项目中蒙特卡洛积分依赖于Ping Pong缓冲。程序向片段着色器传入一个值uSample表示已有的采样数量，并将已经渲染出的结果（Texture A）同样传入片段着色器中。最终的FragmentColor由Texture A（权重为uSample）和本次的光线追踪计算结果（权重为1）加权平均产生。这部分通过WGLFrameBuffer进行实现。在着色器中，只要对光追得到的颜色和上一次渲染的结果进行插值，将结果赋值给fragmentColor即可</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs GLSL"><span class="hljs-comment">//GLSL Shader Code: path-tracing/raytracing/RTShaderUtil.js (FragmentShader)</span><br><span class="hljs-comment">//下面语句位于主函数main()中</span><br><span class="hljs-type">vec4</span> textc = <span class="hljs-built_in">texture</span>(uTexture, <span class="hljs-type">vec2</span>(<span class="hljs-number">1.0</span>-tex.s,tex.t));<br>...<br>fragmentColor = (textc*<span class="hljs-type">float</span>(uSamples) + fragc)/(<span class="hljs-type">float</span>(uSamples)+<span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure><h5 id="2-5-2-光线颜色"><a href="#2-5-2-光线颜色" class="headerlink" title="2.5.2 光线颜色"></a>2.5.2 光线颜色</h5><p>​迭代采样通过一个for循环实现。该循环每次调用<code>fRayCollision</code>判断该光线是否和物体产生碰撞，如果产生碰撞，则将碰撞的光线、颜色等信息返回计算累积光照和累积材质，并根据返回的材质类型判断进行反射的方式，在调用相关的反射函数后，生成下一个光线的起点和方向，进入下一次迭代。</p><p>​在此处我们简化了光照模型。设物体发光辐射为$E_i$，物体材质统称为$M_i$，初始光线颜色为$R$。考虑一个光线正向传播的过程，当其碰到第一个物体时，反射光线的颜色为$RM_1+E_1$，当该反射光线继续触碰第二个物体时，反射光线的颜色为$(RM_1+E_1)M_2+E_2&#x3D;RM_1M_2+M_2E_1+E_2$，利用数学归纳法，可得当反射光线触碰第$N$个物体时，光线的颜色为<br>$$<br>L_{i,N}&#x3D;\left(\sum_{i&#x3D;1}^NM_i\right)R+\sum_{k&#x3D;1}^N\left(\sum_{j&#x3D;k+1}^NM_j\right)E_k<br>$$<br>​容易发现，当$N$为中物体数量时，第$k$个物体发光的颜色需乘上$k+1$至$N$ 编号的物体的材质信息。如果将光线反过来计算，按照路径追踪的想法，这些累积的材质信息可以用一个变量进行维护。</p><p>​下面对所有的物体进行倒序编号，即可得到路径追踪累积颜色的计算方法。</p><p>​设第$m$个物体对最终光线颜色的贡献值为$L_{o,m}$，则<br>$$<br>L_{o,m}&#x3D;E_m\sum_{i&#x3D;1}^{m-1}M_i<br>$$<br>​引入一个累积材质$\alpha_i$，其中$\alpha_i&#x3D;M_i\alpha_{i-1}$，且$\alpha_0&#x3D;1$，此时上式可以写为<br>$$<br>L_{o,m}&#x3D;E_m\alpha_{m-1}<br>$$<br>​设第$k$次迭代后光线的颜色为$L_{c,k}$，则<br>$$<br>L_{c,k}&#x3D;\sum_{i&#x3D;1}^kL_{o,k}<br>$$<br>​同样地，可以用一个累积颜色$\beta_i$进行维护，其中$\beta_i&#x3D;\beta_{i-1}+L_{o,i}$，$\beta_i&#x3D;0$</p><p>​由于$\alpha_i,\beta_i$的信息只用一次，因此算法实际上不需要用数组维护。因此第$k$次迭代所需要做的就是。<br>$$<br>\beta\gets\beta+\alpha E_i<br>$$</p><p>$$<br>\alpha \gets M_i\alpha<br>$$</p><p>​最后，当一束光线没有碰到任何物体时，此时的$E$和上面公式的$R$一样。项目中，我们用天空颜色来标识$R$的值。</p><h5 id="2-5-3-分类讨论各种反射"><a href="#2-5-3-分类讨论各种反射" class="headerlink" title="2.5.3  分类讨论各种反射"></a>2.5.3  分类讨论各种反射</h5><p>​对于漫反射，我们使用Lambert光照模型（这个实际上对应于渲染方程中的$cos\theta$项目，经过Lambert修正后的漫反射的发光颜色根据如下公式进行修正<br>$$<br>E_i’&#x3D;E_i\frac{\vec{N}\vec{D}}{|\vec{N}||\vec{D}|}<br>$$<br>​漫反射的处理代码如下</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//GLSL Shader Code: path-tracing/raytracing/RTShaderUtil.js (FragmentShader)</span><br><span class="hljs-comment">//位于fRaytracing函数中</span><br>rp = fDiffuseReflection(rp,hit.colvex,hit.colnorm);<br><span class="hljs-type">float</span> lambert = <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">dot</span>(hit.colnorm,rp.direction))/<span class="hljs-built_in">length</span>(hit.colnorm)/<span class="hljs-built_in">length</span>(rp.direction);<br>                        accColor = accColor + accMaterial * (hit.emissionColor+ambient) * lambert;<br></code></pre></td></tr></table></figure><p>​镜面反射处理相对容易</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//GLSL Shader Code: path-tracing/raytracing/RTShaderUtil.js (FragmentShader)</span><br><span class="hljs-comment">//位于fRaytracing函数中</span><br>accColor = accColor + accMaterial * (hit.emissionColor+ambient);<br>rp = fSpecularReflection(rp,hit.colvex,hit.colnorm);<br></code></pre></td></tr></table></figure><p>​其他反射将在后续小节中讨论</p><h5 id="2-5-4-最核心的For循环"><a href="#2-5-4-最核心的For循环" class="headerlink" title="2.5.4 最核心的For循环"></a>2.5.4 最核心的For循环</h5><p>​路径追踪所用到的最核心的For循环位于函数<code>fRayTracing</code>中，为了提高效率，一个光线在两种情况下会停止迭代计算。第一种情况是迭代次数超过20次，第二种情况是颜色值小于0.01且迭代次数大于3.</p><p>​另外为了防止浮点误差，反射光线的起始点会在反射方向上进行一小段的位移。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//GLSL Shader Code: path-tracing/raytracing/RTShaderUtil.js (FragmentShader)</span><br><span class="hljs-type">vec4</span> fRaytracing(sRay r)&#123;<br>    sRay rp = r;<br>    <span class="hljs-type">vec4</span> accColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>);<br>    <span class="hljs-type">vec4</span> accMaterial = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>);<br>    <span class="hljs-type">vec4</span> ambient = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>);<br>    <span class="hljs-type">vec4</span> skylight = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>);<br><span class="hljs-comment">//实际代码中该注释行处会通过Javascript的字符串拼接插入对ambient和skylight的赋值</span><br>    <span class="hljs-type">vec2</span> rp_temp=transVec(rp.origin);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i &lt; <span class="hljs-number">20</span>;i+=<span class="hljs-number">1</span>)&#123;<br><br>        rp.direction = rp.direction / <span class="hljs-built_in">length</span>(rp.direction);<br>        sRayCollisionResult hit = fRayCollision(rp);<br>        <span class="hljs-keyword">if</span>(hit.collided == <span class="hljs-literal">false</span>)&#123;<br>            accColor = accColor + accMaterial * skylight; <br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        accMaterial = accMaterial * hit.materialColor;<br>        <span class="hljs-type">float</span> rndsample = rng();<br><br>        <span class="hljs-keyword">if</span>(hit.hitType==<span class="hljs-number">1</span> || (rndsample&lt;<span class="hljs-number">0.3</span>&amp;&amp;hit.hitType==<span class="hljs-number">5</span>))&#123;<br>            rp = fDiffuseReflection(rp,hit.colvex,hit.colnorm);<br>            <span class="hljs-type">float</span> lambert = <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">dot</span>(hit.colnorm,rp.direction))/<span class="hljs-built_in">length</span>(hit.colnorm)/<span class="hljs-built_in">length</span>(rp.direction);<br>            accColor = accColor + accMaterial * (hit.emissionColor+ambient) * lambert;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(hit.hitType==<span class="hljs-number">2</span>)&#123;<br>            accColor = accColor + accMaterial * (hit.emissionColor+ambient);<br>            rp = fSpecularReflection(rp,hit.colvex,hit.colnorm);<br>        &#125;<br>        <span class="hljs-comment">//实际上还有很多else if，此处限于篇幅不赘述</span><br>        rp.origin = rp.origin + rp.direction*<span class="hljs-number">0.002</span>;<br>        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">3</span>&amp;&amp;accMaterial.x&lt;<span class="hljs-number">1e-2</span>&amp;&amp;accMaterial.y&lt;<span class="hljs-number">1e-2</span>&amp;&amp;accMaterial.z&lt;<span class="hljs-number">1e-2</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> accColor;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-6-透明和折射"><a href="#2-6-透明和折射" class="headerlink" title="2.6 透明和折射"></a>2.6 透明和折射</h4><h5 id="2-6-1-折射"><a href="#2-6-1-折射" class="headerlink" title="2.6.1 折射"></a>2.6.1 折射</h5><p>​在折射部分，我们主要使用了斯奈尔定律和经典的折射公式来完成。我们假定一条光线最多只能发生折射和反射中的一种情况，因此我们需要先判断一条光线是否发生了折射，判定代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//GLSL Shader Code: path-tracing/raytracing/RTShaderUtil.js (FragmentShader)</span><br><span class="hljs-type">bool</span> judgeRefract(sRay inr,<span class="hljs-type">vec3</span> p,<span class="hljs-type">vec3</span> N,<span class="hljs-type">float</span> NiOverNt)&#123;<br>    <span class="hljs-type">vec3</span> UV= inr.direction/<span class="hljs-built_in">length</span>(inr.direction);<br>    <span class="hljs-type">float</span> Dt=<span class="hljs-built_in">dot</span>(UV,N);<br>    N = N/<span class="hljs-built_in">length</span>(N);<br>    <span class="hljs-type">float</span> Discriminant=<span class="hljs-number">1.0</span>-NiOverNt*NiOverNt*(<span class="hljs-number">1.0</span>-Dt*Dt);<br>    <span class="hljs-keyword">if</span>(Discriminant&gt;<span class="hljs-number">0.0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​我们是根据上述Discriminant这个参数进行判定的。如果斯奈尔定律是成立的，也就是说折射已经发生了，Discriminant在物理意义上表示$$cos(θ_2)^2$$，这个值是一定在0~1之间的。如果这个Discriminant&lt;0，那么一定表示斯奈尔定律不成立，也就是折射没有发生。</p><p>​当我们确定折射发生之后，我们就可以计算折射后光线的方向，重要代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//GLSL Shader Code: path-tracing/raytracing/RTShaderUtil.js (FragmentShader)</span><br>sRay calRefract(sRay inr,<span class="hljs-type">vec3</span> p,<span class="hljs-type">vec3</span> N,<span class="hljs-type">float</span> matfra)&#123;<br>    <span class="hljs-type">vec3</span> UV= inr.direction/<span class="hljs-built_in">length</span>(inr.direction);<br>    <span class="hljs-type">vec3</span> normvec = N/<span class="hljs-built_in">length</span>(N);<br>    <span class="hljs-type">vec3</span> fnormvec = normvec;<br>    <span class="hljs-type">float</span> Dt=<span class="hljs-built_in">dot</span>(UV,normvec);<br>    <span class="hljs-type">float</span> colfra=<span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">if</span>(Dt&lt;<span class="hljs-number">0.0</span>)&#123;<br>        colfra = <span class="hljs-number">1.0</span>/matfra;<br>        fnormvec=normvec;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        colfra = matfra;<br>        fnormvec=-fnormvec;<br>    &#125;<br>    <span class="hljs-type">float</span> Discriminant=colfra*colfra*(<span class="hljs-number">1.0</span>-Dt*Dt);<br>    <span class="hljs-type">vec3</span> rfm = UV+fnormvec*<span class="hljs-built_in">abs</span>(Dt);<br>    <span class="hljs-type">float</span> cos2 = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span>-Discriminant);<br>    <span class="hljs-type">float</span> sin2 = <span class="hljs-built_in">sqrt</span>(Discriminant);<br>    <span class="hljs-type">float</span> cos1 = <span class="hljs-built_in">abs</span>(Dt);<br>    <span class="hljs-type">float</span> sin1 = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span>-Dt*Dt);<br>    <span class="hljs-type">vec3</span> rfn = rfm*(sin2/cos2*cos1/sin1)-fnormvec*<span class="hljs-built_in">abs</span>(Dt);<br><br>    sRay addrefra=sRay(p, rfn, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-keyword">if</span>(Dt&gt;<span class="hljs-number">0.0</span>)&#123;<br>        addrefra.inrefra = <span class="hljs-number">1.0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        addrefra.inrefra = matfra;<br>    &#125;<br>    <span class="hljs-keyword">return</span> addrefra;<br>&#125;<br></code></pre></td></tr></table></figure><p>​我们先要判断折射情况，一共可以分为两种类型，第一种是第一介质折射到第二介质；第二种是第二介质折射到第一介质。区分这两种类型的参数就是Dt。Dt是入射点法线向量和入射点向量的点击，如果Dt&lt;0，就代表入射点法向量和入射点向量之间的夹角是钝角，也就是第一介质折射到第二介质。反之如果是Dt&gt;0，就代表是第二介质折射到第一介质。</p><p>​再之后，我们可以分别计算$$cos(θ1)$$,$$sin(θ1)$$,$$cos(θ2)$$, $$sin(θ2)$$。我们可以利用矢量和叠加的形式，将X方向的矢量和Y方向的矢量进行叠加就可以得到折射光线的方向。</p><h5 id="2-6-2-毛玻璃材质"><a href="#2-6-2-毛玻璃材质" class="headerlink" title="2.6.2 毛玻璃材质"></a>2.6.2 毛玻璃材质</h5><p>​对于毛玻璃，我们收到了蒙特卡洛积分的启发。当光线碰到毛玻璃材质时以$p$的概率发生漫反射，以$1-p$的概率发生折射。即可实现相应的效果。</p><h4 id="2-7-水面渲染"><a href="#2-7-水面渲染" class="headerlink" title="2.7 水面渲染"></a>2.7 水面渲染</h4><p>​该小节删减</p><h4 id="2-8-其他细节优化"><a href="#2-8-其他细节优化" class="headerlink" title="2.8 其他细节优化"></a>2.8 其他细节优化</h4><h5 id="2-8-1-Gamma-校正"><a href="#2-8-1-Gamma-校正" class="headerlink" title="2.8.1 Gamma 校正"></a>2.8.1 Gamma 校正</h5><p>​因为人眼对光线的感受不是线性的，举个例子，在黑暗时增加一盏灯，那时人眼的感受最明显，往后随着灯数量的增加，人眼对光亮的感觉不会这么明显，事实上<code>显示器输出&lt;人眼接收</code>，因此我们在图像处理的过程中尽可能得保留暗部细节，符合人眼的暗部敏感需求。Gamma校正使用的函数依赖于GLSL的内置pow函数。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//GLSL Shader Code: path-tracing/raytracing/RTShaderUtil.js (FragmentShader)</span><br><span class="hljs-type">vec4</span> fGammaCorrection(<span class="hljs-type">vec4</span> col,<span class="hljs-type">float</span> g)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">vec4</span>(<span class="hljs-built_in">pow</span>(col.x,g),<span class="hljs-built_in">pow</span>(col.y,g),<span class="hljs-built_in">pow</span>(col.z,g),<span class="hljs-built_in">pow</span>(col.w,g));<br>&#125;<br></code></pre></td></tr></table></figure><p>​在最后输出fragmentColor前，进行Gamma校正。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//GLSL Shader Code: path-tracing/raytracing/RTShaderUtil.js (FragmentShader)</span><br><span class="hljs-comment">//下面语句位于主函数main()中</span><br>fragc = fGammaCorrection(fragc/loopsf,<span class="hljs-number">0.40</span>);<br>fragmentColor = (textc*<span class="hljs-type">float</span>(uSamples) + fragc)/(<span class="hljs-type">float</span>(uSamples)+<span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure><h5 id="2-8-2-ForLoop和RequestAnimationFrame的权衡"><a href="#2-8-2-ForLoop和RequestAnimationFrame的权衡" class="headerlink" title="2.8.2 ForLoop和RequestAnimationFrame的权衡"></a>2.8.2 ForLoop和RequestAnimationFrame的权衡</h5><p>​在前端页面使用RequestAnimationFrame实现连续渲染的效果。但在没有优化的情况下，光追渲染进行一次蒙特卡洛采样，然后将结果绘制到Texture上，之后Ping Pong然后就等待下一次的RequestAnimationFrame。该方案渲染对机器的性能要求最低，不会产生机器的卡顿问题，但一个最严重的缺陷是需要等待很久才能够等到光线追踪的结果收敛。一个原因是只进行一次蒙特卡洛采样无法充分利用GPU，频繁地RequestAnimationFrame加大了切换和调用的开销。为了解决该问题，我们才main函数中增加了一个新的For循环，等待多次采样后，才返回fragColor。该优化明显地加速了光追结果的收敛速度。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//GLSL Shader Code: path-tracing/raytracing/RTShaderUtil.js (FragmentShader)</span><br><span class="hljs-type">void</span> main()&#123;<br>    <span class="hljs-type">float</span> loopsf = <span class="hljs-number">5.0</span>;<br>    <span class="hljs-type">float</span> randsrng = <span class="hljs-number">0.001</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> loops = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">vec3</span> nray = ray / <span class="hljs-built_in">length</span>(ray);<br>    <span class="hljs-type">vec4</span> fragc = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>);<br>    <span class="hljs-comment">//在这里进行loops次的采样</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;loops;i++)&#123;<br>        <span class="hljs-type">float</span> px = <span class="hljs-type">float</span>(uSamples)*loopsf+<span class="hljs-type">float</span>(i);<br>        seeds = <span class="hljs-type">uvec2</span>(px, px + <span class="hljs-number">2.0</span>) * <span class="hljs-type">uvec2</span>(<span class="hljs-built_in">gl_FragCoord</span>);<br>        fragc += fRaytracing(sRay(eye, nray + uniformlyRandomDirectionNew() * randsrng,<span class="hljs-number">1.0</span>));<br>    &#125;<br>    <span class="hljs-type">vec4</span> textc = <span class="hljs-built_in">texture</span>(uTexture, <span class="hljs-type">vec2</span>(<span class="hljs-number">1.0</span>-tex.s,tex.t));<br>    fragc = fGammaCorrection(fragc/loopsf,<span class="hljs-number">0.40</span>);<br>    fragmentColor = (textc*<span class="hljs-type">float</span>(uSamples) + fragc)/(<span class="hljs-type">float</span>(uSamples)+<span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-8-3-随机数生成"><a href="#2-8-3-随机数生成" class="headerlink" title="2.8.3 随机数生成"></a>2.8.3 随机数生成</h5><p>​GLSL和C不同，没有内置的随机数函数。因此要产生随机噪声，必须自行构造伪随机函数。在项目实现过程中，自定义的随机数出现了效果差，随机性不好的问题。产生的随机数结果不均匀对最后的渲染质量造成了非常严重的影响。因此我们从网络引用了一个常见的随机数生成函数。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> rng()<br>&#123;<br>    seeds += <span class="hljs-type">uvec2</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">uvec2</span> q = <span class="hljs-number">1103515245</span>U * ( (seeds &gt;&gt; <span class="hljs-number">1</span>U) ^ (seeds.yx) );<br>    <span class="hljs-type">uint</span>  n = <span class="hljs-number">1103515245</span>U * ( (q.x) ^ (q.y &gt;&gt; <span class="hljs-number">3</span>U) );<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">float</span>(n) * (<span class="hljs-number">1.0</span> / <span class="hljs-type">float</span>(<span class="hljs-number">0xffffffff</span>U));<br>&#125;<br></code></pre></td></tr></table></figure><p>​另外为了确保更好的伪随机性能，我们在uniform中增加了一个uTime的值，为当前的时间戳与页面启动的时间戳的差值，uTime将在初始化时被赋值给随机数种子seed。</p><p>​基于上述的随机数，就可以实现随即单位向量（函数<code>uniformlyRandomDirectionNew</code>）等多个功能。</p><h5 id="2-8-4-降噪"><a href="#2-8-4-降噪" class="headerlink" title="2.8.4 降噪"></a>2.8.4 降噪</h5><p>​如果不使用降噪，则光追渲染的结果噪点非常严重。因此我们考虑对初始的光线增加一个微小的扰动，通过引入扰动适当地模糊，来避免噪点严重对渲染质量的影响。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//GLSL Shader Code: path-tracing/raytracing/RTShaderUtil.js (FragmentShader)</span><br><span class="hljs-comment">//下面语句位于主函数main()中</span><br>fragc += fRaytracing(sRay(eye, nray + uniformlyRandomDirectionNew() * randsrng,<span class="hljs-number">1.0</span>));<br></code></pre></td></tr></table></figure><h3 id="3-光子映射"><a href="#3-光子映射" class="headerlink" title="3. 光子映射"></a>3. 光子映射</h3><p>​光子映射主要分为两个部分：生成光子贴图和采样生成颜色，我们将生成光子贴图的部分写在了一个函数里面，采样生成颜色部分则会读取生成的光子贴图来进行计算。</p><p>​生成光子贴图部分，我们规定了一次反射的最大记录次数为60，每次反射的衰减度为0.5，当颜色向量的长度小于0.2时视为被吸收，同时使用了一个随机数来进行随机中止，代码如下所示：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs GLSL"><span class="hljs-comment">//GLSL Shader Code: photon-mapping/raytracing/RTShaderUtil.js (Fragment Shader)</span><br><span class="hljs-type">void</span> fPhotonMapGenerate()&#123;<br>    <span class="hljs-type">int</span> nEmittedPhotons = <span class="hljs-number">30</span>;<br>    <span class="hljs-type">float</span> initCoe = <span class="hljs-number">12.56</span>;<br>    <span class="hljs-type">float</span> reflectRate = <span class="hljs-number">0.5</span>;<br>    <span class="hljs-type">float</span> N = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">float</span> attenCoe = reflectRate/N;<br>    <span class="hljs-type">int</span> maxLoop = <span class="hljs-number">60</span>;<br>    <span class="hljs-type">float</span> reflectRadio = <span class="hljs-number">0.05</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span> ; i&lt;nEmittedPhotons;i++)&#123;<br>        <span class="hljs-type">vec3</span> random = uniformlyRandomDirectionNew();<br>        <span class="hljs-keyword">if</span> (random.y&gt;<span class="hljs-number">0.0</span>)&#123;<br>            random = -random;<br>        &#125;<br>        sRay r = sRay(<span class="hljs-type">vec3</span>(<span class="hljs-number">0.6</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">7</span>),random,<span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span> ; j&lt;maxLoop ; j++)&#123;<br>            sRayCollisionResult hit = fRayCollision(r);<br>            <span class="hljs-keyword">if</span>(hit.collided == <span class="hljs-literal">false</span>)&#123; <br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(hit.hitType==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-type">vec3</span> oldColor = r.color;<br>                r = fDiffuseReflection(r,hit.colvex,hit.colnorm,attenCoe); <br>                r.color = r.color*hit.materialColor.xyz;<br>                photons[phItr] = sPhoton(hit.colvex,r.direction,r.color);<br>                phItr++;<br>                <span class="hljs-keyword">if</span>(phItr==pMaxIndex)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">length</span>(r.color)&lt;<span class="hljs-number">0.2</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(rng()&lt;reflectRadio)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(hit.hitType==<span class="hljs-number">2</span>)&#123;<br>                r = fSpecularReflection(r,hit.colvex,hit.colnorm);<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​采样生成颜色部分，当视线第一次碰撞到漫反射表面的时候就会计算其颜色，计算的公式在之前已经进行过解释，这里便不再赘述，所示代码中取的计算用光子数N&#x3D;50：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs GLSL"><span class="hljs-comment">//GLSL Shader Code: photon-mapping/raytracing/RTShaderUtil.js (Fragment Shader)</span><br><span class="hljs-type">void</span> main()&#123;<br>    seeds = <span class="hljs-type">uvec2</span>(<span class="hljs-type">uint</span>(uTime),<span class="hljs-type">uint</span>(uTime));<br>    fPhotonMapGenerate();<br>    <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> loops = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">vec3</span> nray = ray / <span class="hljs-built_in">length</span>(ray);<br>    <span class="hljs-type">bool</span> isDiffuse = <span class="hljs-literal">false</span>;<br>    sRay r = sRay(eye,nray,<span class="hljs-type">vec3</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>    <span class="hljs-type">vec3</span> collidPos = <span class="hljs-type">vec3</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">vec3</span> collidDir = <span class="hljs-type">vec3</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span> ; i&lt;loops ; i++)&#123;<br>        sRayCollisionResult hit = fRayCollision(r);<br>        <span class="hljs-keyword">if</span>(hit.collided==<span class="hljs-literal">false</span>)&#123;<br>            fragmentColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1.0</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(hit.hitType==<span class="hljs-number">1</span>)&#123;<br>            isDiffuse = <span class="hljs-literal">true</span>;<br>            collidPos = hit.colvex;<br>            collidDir = r.direction;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(hit.hitType==<span class="hljs-number">2</span>)&#123;<br>            r = fSpecularReflection(r,hit.colvex,hit.colnorm);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(isDiffuse)&#123;<br>        <span class="hljs-type">int</span> nMin = <span class="hljs-number">50</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">index</span>[<span class="hljs-number">50</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nMin;j++)&#123;<br>            <span class="hljs-keyword">index</span>[j] = <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-type">float</span> maxMinDis = <span class="hljs-number">-999999.0</span>;<br>        <span class="hljs-type">vec4</span> accColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nMin;j++)&#123;<br>            <span class="hljs-type">float</span> minDis = <span class="hljs-number">999999.0</span>;<br>            <span class="hljs-type">int</span> minIndex = <span class="hljs-number">-1</span>;<br>            <span class="hljs-type">vec3</span> pos = <span class="hljs-type">vec3</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>            <span class="hljs-type">float</span> dis = <span class="hljs-number">0.0</span>;<br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;phItr;i++)&#123;<br>                dis = <span class="hljs-built_in">length</span>(photons[i].position-collidPos);<br>                <span class="hljs-keyword">if</span>(dis&lt;minDis)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;j;k++)&#123;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">index</span>[k]==i)&#123;<br>                            flag = <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(flag)&#123;<br>                        minDis = dis;<br>                        minIndex = i;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(minDis&gt;maxMinDis)&#123;<br>                maxMinDis = minDis;<br>            &#125;<br>            <span class="hljs-type">float</span> flux = <span class="hljs-built_in">dot</span>(<span class="hljs-built_in">normalize</span>(photons[minIndex].direction),collidDir);<br>            accColor = accColor + <span class="hljs-type">vec4</span>(<span class="hljs-built_in">max</span>(flux,<span class="hljs-number">0.0</span>)*photons[minIndex].color,<span class="hljs-number">1.0</span>);<br>        &#125;<br><br>        accColor = accColor/(maxMinDis*maxMinDis*<span class="hljs-number">3.14</span>*<span class="hljs-type">float</span>(phItr));<br>        <span class="hljs-type">vec4</span> textc = <span class="hljs-built_in">texture</span>(uTexture, <span class="hljs-type">vec2</span>(<span class="hljs-number">1.0</span>-tex.s,tex.t));<br>        <span class="hljs-type">vec4</span> fragc = accColor;<br>        fragmentColor = (textc*<span class="hljs-type">float</span>(uSamples) + fragc)/(<span class="hljs-type">float</span>(uSamples)+<span class="hljs-number">1.0</span>);<br>        fragmentColor.x = <span class="hljs-built_in">min</span>(<span class="hljs-number">1.0</span>,fragmentColor.x);<br>        fragmentColor.y = <span class="hljs-built_in">min</span>(<span class="hljs-number">1.0</span>,fragmentColor.y);<br>        fragmentColor.z = <span class="hljs-built_in">min</span>(<span class="hljs-number">1.0</span>,fragmentColor.z);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">vec4</span> textc = <span class="hljs-built_in">texture</span>(uTexture, <span class="hljs-type">vec2</span>(<span class="hljs-number">1.0</span>-tex.s,tex.t));<br>    fragmentColor = (textc*<span class="hljs-type">float</span>(uSamples))/(<span class="hljs-type">float</span>(uSamples));<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>本文档中引用的文献有：</p><p>[1] AainSvck. 光子映射总结（1&#x2F;4）：基本全局光子映射（Basic Photon Mapping）[EB&#x2F;OL]. (2020-09-07) [2022-01-14] <a href="https://zhuanlan.zhihu.com/p/208356944">https://zhuanlan.zhihu.com/p/208356944</a></p><p>[2] Folkegard, Niklas. Dynamic Code Generation for Realtime Shaders [EB&#x2F;OL]. (2004)  [2022-01-14] <a href="https://ep.liu.se/ecp/013/005/ecp01305.pdf">https://ep.liu.se/ecp/013/005/ecp01305.pdf</a></p><p>在项目的实现过程中，也参考了很多教程和开源项目的相关技术原理。通过了解这些教程和相关的开源项目的相关后，我们在相关技术实现上的障碍也能够解决，下列参考排序不分先后和重要性。<strong>下列项目在项目开发过程中仅做技术性参考，主体开发工作仍由小组成员独立实现。</strong></p><p>[a] MDN. WebGL教程 [EB&#x2F;OL]. (2022-01-14) [2022-01-14] <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial">https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial</a> （了解基础的WebGL相关框架、语法和流程）</p><p>[b] Evan Wallace. WebGL Path Tracing [EB&#x2F;OL]. (2010) [2022-01-14] <a href="https://madebyevan.com/webgl-path-tracing/">https://madebyevan.com/webgl-path-tracing/</a> （受到该项目和其它类似的参考文献的思路的影响，我们采用了动态代码生成的思路编写片段着色器代码）</p><p>[c] Erich Loftis. Threejs Path Tracing Renderer [EB&#x2F;OL]. [2022-01-14] <a href="https://github.com/erichlof/THREE.js-PathTracing-Renderer%EF%BC%88%E6%8F%90%E4%BE%9B%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%8C%E6%B0%B4%E9%9D%A2%E7%94%9F%E6%88%90%E5%99%AA%E5%A3%B0%E7%AD%89%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B8%AE%E5%8A%A9%EF%BC%89">https://github.com/erichlof/THREE.js-PathTracing-Renderer（提供随机数，水面生成噪声等相关的帮助）</a></p><p>[d] GFX Fundamentals. WebGL Fundamentals [EB&#x2F;OL]. [2022-01-14] <a href="https://webglfundamentals.org/%EF%BC%88WebGL%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%99%E7%A8%8B%EF%BC%89">https://webglfundamentals.org/（WebGL的一些相关的教程）</a></p><p>[e] Peter Shirley. Ray Tracing in One Weekend [M&#x2F;OL]. [2022-01-14] <a href="https://raytracing.github.io/">https://raytracing.github.io/</a> （光线追踪的基本原理的了解）</p><p>[f]  Peter Shirley. Ray Tracing: the Rest of Your Life [M&#x2F;OL]. [2022-01-14] <a href="https://raytracing.github.io/">https://raytracing.github.io/</a> （光线追踪的基本原理的了解）</p><p>[g] Khronos. OpenGL4 Reference Pages [EB&#x2F;OL]. [2022-01-14] <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/index.php%EF%BC%88GLSL%E7%9A%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89">https://www.khronos.org/registry/OpenGL-Refpages/gl4/index.php（GLSL的相关函数的使用）</a></p><p>[h] FaithBook. 一周实现光线追踪（十）玻璃材质 [EB&#x2F;OL]. [2022-01-14] <a href="https://www.bilibili.com/read/cv11990396%EF%BC%88%E5%8F%82%E8%80%83%E6%8A%98%E5%B0%84%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BD%86%E8%AF%A5%E8%B5%84%E6%96%99%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A8%E5%AF%BC%E5%92%8C%E5%AE%9E%E7%8E%B0%E6%9C%89%E9%94%99%E8%AF%AF%EF%BC%8C%E5%B0%8F%E7%BB%84%E5%9C%A8%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%BF%9B%E8%A1%8C%E4%BA%86%E9%87%8D%E6%96%B0%E9%AA%8C%E8%AF%81%E6%8E%A8%E5%AF%BC%E4%BB%A5%E5%8F%8A%E4%BF%AE%E6%AD%A3%EF%BC%89">https://www.bilibili.com/read/cv11990396（参考折射的原理，但该资料中的一些推导和实现有错误，小组在实现过程中进行了重新验证推导以及修正）</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>(MI)Course</tag>
      
      <tag>(CS)Computer Graphics</tag>
      
      <tag>(SE)Web Techniques</tag>
      
      <tag>(MI)Collaboration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(ML/ASR) Speech Signal Analysis</title>
    <link href="/2020/10/10/ml-asr-1-speech-signal-analysis/"/>
    <url>/2020/10/10/ml-asr-1-speech-signal-analysis/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>The goal of this assignement is to generate acoustic features like Mel Frequency Cepstral Coefficient (MFCC) for a segment of speech. The process of speech signal analysis covers steps including pre-emphasis, windowing, Short Time Fourier transform (STFT) and so on.</p><h3 id="2-Pre-emphasis"><a href="#2-Pre-emphasis" class="headerlink" title="2. Pre-emphasis"></a>2. Pre-emphasis</h3><p>Pre-emphasis is the first step of the speech signal analysis. The goal of this process is to increase the magnitude of higher frequencies in the speech signal compared with those with lower frequencies. According to the analysis of glottal source and several physical laws like the Acoustic attenuation law, signals with higher frequencies tend to attenuate and have less signal.  </p><p>Pre-emphasis use the following formula to transform the speech signal. Where $\alpha$​​​ is the pre-emphasis factor, ususally ranged from 0.95 to 0.99. In this assignment, the factor defaults to 0.97.<br>$$<br>x_t^{‘}&#x3D;x_t-\alpha x_{t-1}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">audio_preemphasis</span>(<span class="hljs-params">audio_signal, preemphasis_factor=PREEMPHASIS_FACTOR</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Apply the pre-emphasis transform on an audio sequence</span><br><span class="hljs-string">    :param audio_signal: (ndarray) input audio sequence</span><br><span class="hljs-string">    :param preemphasis_factor: (float) factor of pre-emphasis</span><br><span class="hljs-string">    :return: (ndarray) pre-emphasized audio sequence</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    audio_shift = np.concatenate((audio_signal[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(audio_signal)], [<span class="hljs-number">0</span>]), <span class="hljs-number">0</span>)<br>    audio_preemphasized = audio_shift - audio_signal * preemphasis_factor<br>    <span class="hljs-keyword">return</span> audio_preemphasized, audio_signal<br></code></pre></td></tr></table></figure><h3 id="3-Windowing"><a href="#3-Windowing" class="headerlink" title="3. Windowing"></a>3. Windowing</h3><p>Actually, our speech signal is non-stationary. This contradicts with the settings of the signal processing algorithms, which perceive signals as stationary sequences. To solve this problem, windowing is introduced.</p><p>In windowing processing, we divided the audio signal into several frames. The division operation contains two vital parameters.</p><ul><li>Frame Width. Frame width defines the window size of each frames, for acoustic signal recognition, the value defaults to 25 milliseconds.</li><li>Frame Shift. In acoustic signal recognition, the semantic information is continuous. To preserve the continuity, we allow a following frame overlap with its predecessor frame. For example, now we select a frame with starting timestamp $a$, and we define the frame shift $b$, then the start timestamp of the following frame should be $a+b$</li></ul><p>When windowing comes to practice, we need padding zeros to ensure that the last frame can be successfully made. This ensures the signal length satisfies the formula below.<br>$$<br>Padded_audio_length &#x3D; Frame_width+Frame_shift\times k,k\in\mathbb{Z}<br>$$<br>where $k+1$ equals number of frames</p><p>Also, in windowing step, Hamming and Hanning windows are commonly used.</p><p>The code is shown below</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">audio_windowing</span>(<span class="hljs-params">audio_signal, sampling_rate, windowing_factor=WINDOWING_FACTOR, frame_shift_ms=FRAME_SHIFT_MS,</span><br><span class="hljs-params">                    frame_size_ms=FRAME_SIZE_MS</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Divide the audio sequence into tiny windows.</span><br><span class="hljs-string">    :param audio_signal: (ndarray,1d) input audio sequence</span><br><span class="hljs-string">    :param sampling_rate: (int/float) the sample frequence of the input audio sequence</span><br><span class="hljs-string">    :param windowing_factor: (float) the weight factor used in Hanning or Hamming window</span><br><span class="hljs-string">    :param frame_shift_ms: (int) the increment of the start point between two adjacent window</span><br><span class="hljs-string">    :param frame_size_ms: (int) the length of each window</span><br><span class="hljs-string">    :return: (ndarray,2d) windowed audio sequence</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    audio_len = <span class="hljs-built_in">len</span>(audio_signal)<br>    frame_size = <span class="hljs-built_in">int</span>(frame_size_ms* sampling_rate / <span class="hljs-number">1000</span> )<br>    frame_shift = <span class="hljs-built_in">int</span>(frame_shift_ms * sampling_rate / <span class="hljs-number">1000</span>)<br>    audio_paddings = (frame_size - audio_len) % frame_shift<br>    audio_signal_padded = np.pad(audio_signal, (<span class="hljs-number">0</span>, audio_paddings), mode=<span class="hljs-string">&quot;constant&quot;</span>, constant_values=(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    frame_count = (<span class="hljs-built_in">len</span>(audio_signal_padded) - frame_size) // frame_shift + <span class="hljs-number">1</span><br>    frame_window = np.zeros((frame_count, frame_size))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;AUDIO LEN&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(audio_signal_padded))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(frame_count):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(frame_shift * i, frame_shift * i + frame_size):<br>            t = j - frame_shift * i<br>            frame_window[i, t] = audio_signal_padded[j] * (<br>                    (<span class="hljs-number">1</span> - windowing_factor) - windowing_factor * np.cos(<span class="hljs-number">2</span> * np.pi * t / (frame_size - <span class="hljs-number">1</span>)))<br>    frame_window_transformed = frame_window.copy()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Windowing: done&quot;</span>)<br>    <span class="hljs-keyword">return</span> frame_window_transformed, frame_count, frame_size<br></code></pre></td></tr></table></figure><h3 id="4-Short-time-Fourier-Transform-STFT"><a href="#4-Short-time-Fourier-Transform-STFT" class="headerlink" title="4. Short-time Fourier Transform (STFT)"></a>4. Short-time Fourier Transform (STFT)</h3><p>For every frame we get from the windowing step, we perform discrete Fourier Transform on it. This operation converts signals from time domain to frequency domain. To perform discrete Fourier Transform, Fast Fourier Transform algorithm is used.</p><h4 id="4-1-Fourier-Series"><a href="#4-1-Fourier-Series" class="headerlink" title="4.1 Fourier Series"></a>4.1 Fourier Series</h4><p>Before the explanation of Fourier Transformation, Fourier Series should be explained first.</p><p>We all know that, any periodic function can be rewritten in the Fourier-series form:<br>$$<br>f(x)&#x3D;A_0+\sum_{k&#x3D;1}^{\infty}(a_k\cos(k x)+b_k\sin(k x))<br>$$<br>First, we need calculate the coefficient $A_0$<br>$$<br>\int_{-\pi}^{\pi}f(x)\mathrm{d}x&#x3D;2\pi A_0+\sum_{k&#x3D;1}^{\infty}(\int_{-\pi}^{\pi}a_k\cos(k x)\mathrm{d}x+\int_{-\pi}^{\pi}b_k\sin(k x)\mathrm{d}x)&#x3D;2\pi A_0<br>$$<br>Thus,<br>$$<br>A_0&#x3D;\frac{1}{2\pi}\int_{-\pi}^{\pi}f(x)\mathrm{d}x<br>$$<br>Next, calculate the coefficients $a_k$<br>$$<br>\int_{-\pi}^{\pi}f(x)\cos(n x)\mathrm{d}x&#x3D;\int_{-\pi}^{\pi}A_0\cos(n x)\mathrm{d}x+\sum_{k&#x3D;1}^{\infty}(\int_{-\pi}^{\pi}a_k\cos(k x)\cos(n x)\mathrm{d}x+\int_{-\pi}^{\pi}b_k\sin(k x)\cos(n x)\mathrm{d}x)&#x3D;2\pi A_0<br>$$</p><p>Simplify the equation above.<br>$$<br>\int_{-\pi}^{\pi}f(x)\cos(n x)\mathrm{d}x&#x3D;\int_{-\pi}^{\pi}a_n\cos^2(n x)\mathrm{d}x&#x3D;\int_{-\pi}^{\pi}a_n(\frac{1+cos(2n x)}{2})\mathrm{d}x&#x3D;a_n\pi<br>$$<br>Thus,<br>$$<br>a_k&#x3D;\frac{1}{\pi}\int_{-\pi}^{\pi}f(x)\cos(k x)\mathrm{d}x<br>$$<br>Similarly, we can get<br>$$<br>b_k&#x3D;\frac{1}{\pi}\int_{-\pi}^{\pi}f(x)\sin(k x)\mathrm{d}x<br>$$<br>Assuming the period of the function is $T$​, we can convert it into a new function with period of $2\pi$<br>$$<br>t&#x3D;\frac{2\pi x}{T}; f(x)&#x3D;f(\frac{2\pi x}{T})&#x3D;g(t)<br>$$<br>Then,<br>$$<br>f(x)&#x3D;g(t)&#x3D;\frac{a_0}{2}+\sum_{k&#x3D;1}^{\infty}(a_k\cos(\frac{2\pi k x}{T} )+b_k\sin(\frac{2\pi k x}{T} ))<br>$$<br>Where,<br>$$<br>a_0&#x3D;\frac{1}{\pi}\int_{-\pi}^{\pi}g(t)\mathrm{d}t&#x3D;\frac{2}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(x)\mathrm{d}x<br>$$</p><p>$$<br>a_k&#x3D;\frac{1}{\pi}\int_{-\pi}^{\pi}g(t)\cos(k x)\mathrm{d}t&#x3D;\frac{2}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(x)\cos(\frac{2\pi k x}{T})\mathrm{d}x<br>$$</p><p>$$<br>b_k&#x3D;\frac{1}{\pi}\int_{-\pi}^{\pi}g(t)\sin(k x)\mathrm{d}t&#x3D;\frac{2}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(x)\sin(\frac{2\pi k x}{T})\mathrm{d}x<br>$$</p><h4 id="4-2-Fourier-Series-in-the-Complex-Form"><a href="#4-2-Fourier-Series-in-the-Complex-Form" class="headerlink" title="4.2 Fourier Series in the Complex Form"></a>4.2 Fourier Series in the Complex Form</h4><p>According to the Euler‘s Formula, we can convert trigonometric functions into corresponding complex forms.<br>$$<br>e^{ix}&#x3D;cos(x)+isin(x);e^{-ix}&#x3D;cos(x)-isin(x)<br>$$<br>Thus, we can transform sine function and cosine function into complex forms.<br>$$<br>\cos(x)&#x3D;\frac{e^{ix}+e^{-ix}}{2}<br>$$</p><p>$$<br>sin(x)&#x3D;\frac{e^{ix}-e^{-ix}}{2i}<br>$$</p><p>Then, the coefficients in the Fourier Series can be written in the complex form<br>$$<br>a_k&#x3D;\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(x)\left(\exp(\frac{2\pi k ix}{T})+\exp(-\frac{2\pi k ix}{T})\right)\mathrm{d}x<br>$$</p><p>$$<br>b_k&#x3D;\frac{1}{Ti}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(x)\left(\exp(\frac{2\pi k ix}{T})-\exp(-\frac{2\pi k ix}{T})\right)\mathrm{d}x<br>$$</p><p>$$<br>b_k&#x3D;-\frac{i}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(x)\left(\exp(\frac{2\pi k ix}{T})-\exp(-\frac{2\pi k ix}{T})\right)\mathrm{d}x<br>$$</p><p>Also, the original formula can be also rewritten<br>$$<br>f(x)&#x3D;\frac{a_0}{2}+\frac{1}{2}\sum_{k&#x3D;1}^{\infty}(a_k\left(\exp(\frac{2\pi k ix}{T})+\exp(-\frac{2\pi k ix}{T})\right)+\frac{b_k}{i}\left(\exp(\frac{2\pi k ix}{T})-\exp(-\frac{2\pi k ix}{T})\right) )<br>$$<br>So,<br>$$<br>f(x)&#x3D;\frac{a_0}{2}+\frac{1}{2}\sum_{k&#x3D;1}^{\infty}\left(\exp(\frac{2 \pi k ix}{T})\left(a_k+\frac{b_k}{i}\right)+\exp(-\frac{2\pi k ix}{T})\left(a_k-\frac{b_k}{i}\right)\right)<br>$$</p><p>$$<br>f(x)&#x3D;\frac{a_0}{2}+\frac{1}{2}\sum_{k&#x3D;1}^{\infty}\left(\exp(\frac{2\pi k ix}{T})\left(a_k-ib_k\right)+\exp(-\frac{2\pi k ix}{T})\left(a_k+ib_k\right)\right)<br>$$</p><p>We can define new variable $c_k$ and $d_k$ to simplify the expression<br>$$<br>c_k&#x3D;a_k-ib_k; d_k&#x3D;a_k+ib_k<br>$$<br>Then,<br>$$<br>c_k&#x3D;\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(x)\left(\exp(\frac{2\pi k ix}{T})+\exp(-\frac{2\pi k ix}{T})\right)\mathrm{d}x-\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(x)\left(\exp(\frac{2\pi k ix}{T})-\exp(-\frac{2\pi k ix}{T})\right)\mathrm{d}x<br>$$<br>After the simplification, we can get<br>$$<br>c_k&#x3D;\frac{2}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(x)\exp(-\frac{2\pi k ix}{T})\mathrm{d}x<br>$$<br>Similarly,<br>$$<br>d_k&#x3D;\frac{2}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(x)\exp(\frac{2\pi k ix}{T})\mathrm{d}x<br>$$<br>We can find the relation between $c_k$  and $d_k$<br>$$<br>d_k&#x3D;c_{-k}<br>$$<br>So,<br>$$<br>f(x)&#x3D;\frac{a_0}{2}+\frac{1}{2}\sum_{k&#x3D;1}^{\infty}\left(\exp(\frac{2\pi k ix}{T})c_k+\exp(-\frac{2\pi k ix}{T})c_{-k}\right)<br>$$<br>After the simplification, we can finally get<br>$$<br>f(x)&#x3D;\frac{1}{2}\sum_{k&#x3D;-\infty}^{\infty}\left(\exp(\frac{2\pi k ix}{T})c_k\right )<br>$$</p><p>Also, if we modify the constant factor in $c_n$<br>$$<br>c_k&#x3D;\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(x)\exp(-\frac{2\pi k ix}{T})\mathrm{d}x<br>$$<br>The Fourier Series formula can be written in the expression below<br>$$<br>f(x)&#x3D;\sum_{k&#x3D;-\infty}^{\infty}\left(\exp(\frac{2\pi k ix}{T})c_k\right )<br>$$</p><h4 id="4-3-Fourier-Transform"><a href="#4-3-Fourier-Transform" class="headerlink" title="4.3 Fourier Transform"></a>4.3 Fourier Transform</h4><p>According to the Fourier Series Formula, we can get<br>$$<br>f(x)&#x3D;\sum_{k&#x3D;-\infty}^{\infty}\left(\exp(\frac{2\pi k ix}{T})\left(\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(x)\exp(-\frac{2\pi k ix}{T})\mathrm{d}x\right )\right)<br>$$<br>We can replace the period time with the frequency<br>$$<br>f(x)&#x3D;\sum_{k&#x3D;-\infty}^{\infty}\left(\exp(k\omega ix)\left(\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(x)\exp(-k\omega ix)\mathrm{d}x\right )\right)<br>$$<br>When $T\to \infty$, then $ \omega \to 0$ . Thus When $T \to \infty$, we have<br>$$<br>f(x)&#x3D;\int_{-\infty}^{\infty}\left(\exp(\omega ix)\left(\frac{1}{2\pi}\int_{-\infty}^{\infty}f(x)\exp(-\omega ix)\mathrm{d}x\right )\right)\mathrm{d}\omega<br>$$<br>So, the Fourier Transform can be written as<br>$$<br>F(\omega)&#x3D;\int_{-\infty}^{\infty}\exp(-\omega it)f(t)\mathrm{d}t<br>$$</p><p>$$<br>f(t)&#x3D;\frac{1}{2\pi}\int_{-\infty}^{\infty}\exp(\omega it)F(\omega)\mathrm{d}\omega<br>$$</p><h4 id="4-4-Discrete-Fourier-Transform-DFT"><a href="#4-4-Discrete-Fourier-Transform-DFT" class="headerlink" title="4.4 Discrete Fourier Transform (DFT)"></a>4.4 Discrete Fourier Transform (DFT)</h4><p>For computers, discrete data might be an optimal choice compared to continuous data. The Fourier Transform formula given above is perfect, but it is hard to implement the algorithm on computers. Thus, we need a discrete algorithm for the Fourier Transform. Therefore, Discrete Fourier Transform algorithm is introduced. The principles of DFT are as follow.</p><p>Let $x_n$​ be sampling points. Then we sample following angular frequencies.<br>$$<br>\omega_n &#x3D; \frac{2\pi n}{N}<br>$$<br>The transform from time domain to frequency domain can be described as the equation below.<br>$$<br>F(n)&#x3D;\sum_{t&#x3D;0}^{N-1}\exp(-\frac{2\pi n}{N}it)x_t<br>$$<br>And its corresponding inverse transform (IDFT) can be described as the equation below.<br>$$<br>f(t)&#x3D;\frac{1}{N}\sum_{n&#x3D;0}^{N-1}\exp(\frac{2\pi n}{N}it)F(n)<br>$$<br>We can define the matrix of time domain as<br>$$<br>X&#x3D;(x_0,x_1,…,x_n)^T<br>$$<br> and the matrix of frequency domain as<br>$$<br>Y&#x3D;(X_1,…,X_n)^T<br>$$</p><p>DFT can be written in a matrix<br>$$<br>W&#x3D;{a_{nt}}<br>$$</p><p>$$<br>a_{nt}&#x3D;\exp(-\frac{2\pi n}{N}it)<br>$$</p><p>Then, $Y$ can be calculated by<br>$$<br>Y&#x3D;WX<br>$$<br>IDFT can also be written in a matrix form. $I&#x3D;b_{tn}$<br>$$<br>b_{tn}&#x3D;\exp(\frac{2\pi n}{N}it)&#x3D;\frac{1}{a_{nt}}<br>$$<br>Then, $X$​ can be calculated by<br>$$<br>X&#x3D;IY<br>$$</p><h4 id="4-5-Fast-Fourier-Transform-FFT"><a href="#4-5-Fast-Fourier-Transform-FFT" class="headerlink" title="4.5 Fast Fourier Transform (FFT)"></a>4.5 Fast Fourier Transform (FFT)</h4><p>Fast Fourier Transform algorithm is an optimal implementation of discrete Fourier transform, which reduces time complexity from $O(n^2)$ to $O(\log_2(n))$</p><p>Before diving into the details of Fast Fourier Transform, we need to define unit roots $\omega_n^{k}$​<br>$$<br>\omega_n^k&#x3D;\cos(\frac{2\pi k}{n})+i\sin(\frac{2\pi k}{n})<br>$$<br>Then, we can discover following rules:</p><p>Rule #1<br>$$<br>\omega_{2n}^{2k}&#x3D;\omega_{n}^{k}<br>$$<br>Rule #2<br>$$<br>\omega_{n}^{k+\frac{n}{2}}&#x3D;-\cos(\frac{2\pi k}{n})-i\sin(\frac{2\pi k}{n})&#x3D;-\omega_{n}^{k}<br>$$<br>The unit root can also be written in the complex form.<br>$$<br>\omega_n^k&#x3D;\exp(\frac{2\pi k i}{n})<br>$$<br>Thus, DFT transform can be written in the expression below:<br>$$<br>F(n)&#x3D;\sum_{t&#x3D;0}^{N-1}\omega_N^{-nt}x_t<br>$$<br>And, IDFT transform can be written as<br>$$<br>f(t)&#x3D;\sum_{n&#x3D;0}^{N-1}\omega_N^{nt}F(n)<br>$$<br>Consider the written form of DFT transform, we can divide it into two parts. (Assuming $N&#x3D;2^p$)<br>$$<br>F(n)&#x3D;\sum_{t&#x3D;0}^{\frac{N}{2}-1}\omega_N^{-2nt}x_{2t}+\sum_{t&#x3D;0}^{\frac{N}{2}-1}\omega_N^{-2nt-n}x_{2t+1}<br>$$</p><p>$$<br>F(n)&#x3D;\sum_{t&#x3D;0}^{\frac{N}{2}-1}\omega_N^{-2nt}x_{2t}+\omega_{N}^{-n}\sum_{t&#x3D;0}^{\frac{N}{2}-1}\omega_N^{-2nt}x_{2t+1}<br>$$</p><p>Then, we can find that we can recursively calculate the expression<br>$$<br>F(n)&#x3D;F_1(n)+\omega_{N}^{-n}F_2(n)<br>$$<br>Consider the calculation of $F_1$​<br>$$<br>F_1(n)&#x3D;\sum_{t&#x3D;0}^{\frac{N}{2}-1}\omega_N^{-2nt}x_{2t}&#x3D;\sum_{t&#x3D;0}^{\frac{N}{4}-1}\omega_N^{-4nt}x_{4t}+\omega_{N}^{-2n}\sum_{t&#x3D;0}^{\frac{N}{4}-1}\omega_N^{-4nt}x_{4t+2}<br>$$<br>We can similarly calculate $F_2$</p><p>Consider the expression $F(n)$<br>$$<br>F(n+\frac{N}{2})&#x3D;\sum_{t&#x3D;0}^{\frac{N}{2}-1}\omega_N^{-2nt}\omega_N^{-Nt} x_{2t}+\sum_{t&#x3D;0}^{\frac{N}{2}-1}\omega_N^{-2nt-n}\omega_N^{-Nt}\omega_N^{-\frac{N}{2}}x_{2t+1}&#x3D;F_1(n)-\omega_N^{-n}F_2(n)<br>$$<br>Thus, we only need to calculate $F(n),n\leq \frac{N}{2}$​​ recursively </p><h4 id="4-6-Perform-Fast-Fourier-Transform-on-Frames"><a href="#4-6-Perform-Fast-Fourier-Transform-on-Frames" class="headerlink" title="4.6 Perform Fast Fourier Transform on Frames"></a>4.6 Perform Fast Fourier Transform on Frames</h4><p>In this assignment, I use <code>Numpy</code> package to calculate the transformed results. In <code>Numpy</code>, number of FFT bins does not need to be the power of 2. However, I make the number of bins the power of 2 to follow the convention. After the transform, complex numbers are all turned to real numbers by calculating their squared complex distances (the squared absolute value of complexes)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">audio_fft</span>(<span class="hljs-params">frame_window, frame_count</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Apply the STFT on the audio sequence</span><br><span class="hljs-string">    :param frame_window: (ndarray,2d) input windowed audio sequence</span><br><span class="hljs-string">    :param frame_count: (int) count of windowed frames</span><br><span class="hljs-string">    :return: (ndarray,2d ; int) spectrogram of the audio sequence and fft bins</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    frame_window_transformed = []<br>    fft_bins = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># Make the bin of FFT be the power of 2</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> fft_bins &lt; frame_window.shape[<span class="hljs-number">1</span>]:<br>            fft_bins = fft_bins * <span class="hljs-number">2</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-comment"># Perform FFT</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(frame_count):<br>        freq_amp = np.fft.rfft(frame_window[i], fft_bins)<br>        freq_amp_real = np.real(freq_amp)<br>        freq_amp_imag = np.imag(freq_amp)<br>        freq_amp_dist = (freq_amp_imag * freq_amp_imag + freq_amp_real * freq_amp_real)<br>        frame_window_transformed.append(freq_amp_dist)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;DFT: done&quot;</span>)<br>    <span class="hljs-keyword">return</span> np.array(frame_window_transformed), fft_bins<br></code></pre></td></tr></table></figure><h3 id="5-Mel-Filter-Bank-amp-Log-Feature"><a href="#5-Mel-Filter-Bank-amp-Log-Feature" class="headerlink" title="5. Mel Filter Bank &amp; Log Feature"></a>5. Mel Filter Bank &amp; Log Feature</h3><p>For human, hearing is less sensitive to signals with higher frequencies. In other word, our perception of frequencies can be represented by a non-linear function. In 1937, Stevens, Volkmann and Newman proposed a new perceptual scale of pitches judged by listeners. The name of the proposed scale is Mel scale. The relation of Mel frequency and normal frequency can be illustrated by the formula below.<br>$$<br>f_{mel}(f)&#x3D;1127\ln(1+\frac{f}{700})<br>$$<br>With the help of Mel frequency, we can readjust feature extracted by STFT to make it meets our perceptual characteristics. Such processing is called Mel Filter Bank.</p><p>The processing procedure contains following steps.</p><ol><li><p>Define basic parameters of the filters. Including the lower bound of frequencies $f_L$​, higher bound of frequencies $f_H$​, number of filters to be used $N$​, number of FFT bins used $N_{fft}$​ , sampling rate $f_s$. In most cases, $f_L$ defaults to 300 Hz and $f_H$ defaults to 8000 Hz (or the half of the sampling rate). $N$ always defaults to 26</p></li><li><p>Convert the upper and lower frequencies to their corresponding Mel frequency.<br>   $$<br>   f_{mel}(f_L)&#x3D;1127\ln(1+\frac{f_L}{700})<br>   $$</p></li></ol><p>   $$<br>   f_{mel}(f_H)&#x3D;1127\ln(1+\frac{f_H}{700})<br>   $$</p><ol start="3"><li><p>Select $N+2$ points from $\left[f_{mel}(f_L),f_{mel}(f_H)\right]$ uniformly. For the i-th point, its Mel frequency is<br>$$<br>f_{mel}(f_i)&#x3D;(f_{mel}(f_H)-f_{mel}(f_L))\times i+f_{mel}(f_L)<br>$$</p></li><li><p>Convert the Mel frequencies back to Hertz (normal frequencies). This uses the inverse function of Mel scale<br>$$<br>f_{mel}^{-1}(f)&#x3D;700(\exp(\frac{m}{1127})-1)<br>$$</p><p>$$<br>f_i&#x3D;f_{mel}^{-1}((f_{mel}(f_H)-f_{mel}(f_L))\times i+f_{mel}(f_L))<br>$$</p></li><li><p>Round frequencies to the nearest fft bin<br>$$<br>h(i)&#x3D;\lfloor(N_{fft}+1)\times \frac{f_i}{f_s}\rfloor<br>$$</p></li><li><p>Create filter bank matrix $M$ with $N$ rows and $\frac{N_{fft}}{2}+1$ columns. For i-th filter and j-th FFT bin, the element in the matrix can be calculated by the following formula.<br>$$<br>M(i,j)&#x3D;0,\quad j&lt;f(i-1),or\quad j&gt;f(i+1)\<br>M(i,j)&#x3D;\frac{k-f(i-1)}{f(i)-f(i-1)},\quad f(i-1)\leq j&lt; f(i)\<br>M(i,j)&#x3D;\frac{f(i-1)-k}{f(i+1)-f(i)},\quad f(i)&lt; j\leq f(i+1)<br>$$</p></li></ol><p>Now, filter bank can be created via codes</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_mel_filter_banks</span>(<span class="hljs-params">sampling_freq, fft_size, filters=MEL_FILTERS, low_freq=MEL_FILTER_LOW_FREQ,</span><br><span class="hljs-params">                         high_freq=MEL_FILTER_HIGH_FREQ</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Get the matrix for FFT-bins-aligned Mel filter bank matrix</span><br><span class="hljs-string">    :param sampling_freq: (int) Sampling frequency</span><br><span class="hljs-string">    :param fft_size: (int) Size of FFT bins</span><br><span class="hljs-string">    :param filters:  (int) Size of output numbers of Mel filters</span><br><span class="hljs-string">    :param low_freq: (int) the lower bound frequency of Mel filters</span><br><span class="hljs-string">    :param high_freq:  (int) the higher bound frequency of Mel filters</span><br><span class="hljs-string">    :return: (ndarray,2d) Filter matrix, each row corresponds to a Mel filter, each column corresponds to a FFT bin</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    m_freqs = np.array([mel_freq(low_freq) + i * (mel_freq(high_freq) - mel_freq(low_freq)) / (filters + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span><br>                        <span class="hljs-built_in">range</span>(filters + <span class="hljs-number">2</span>)])<br>    norm_freqs = mel_freq_inverse(m_freqs)<br>    fft_aligned_freq = np.floor((fft_size / sampling_freq) * norm_freqs)<br>    mel_filters = np.zeros((filters, fft_size // <span class="hljs-number">2</span> + <span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(filters):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(fft_size):<br>            <span class="hljs-keyword">if</span> fft_aligned_freq[i + <span class="hljs-number">1</span>] &gt;= j &gt; fft_aligned_freq[i]:<br>                mel_filters[i, j] = (j - fft_aligned_freq[i]) / (fft_aligned_freq[i + <span class="hljs-number">1</span>] - fft_aligned_freq[i])<br>            <span class="hljs-keyword">elif</span> fft_aligned_freq[i + <span class="hljs-number">1</span>] &lt; j &lt; fft_aligned_freq[i + <span class="hljs-number">2</span>]:<br>                mel_filters[i, j] = (fft_aligned_freq[i + <span class="hljs-number">2</span>] - j) / (fft_aligned_freq[i + <span class="hljs-number">2</span>] - fft_aligned_freq[i + <span class="hljs-number">1</span>])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Get Mel-filter Bank: done&quot;</span>)<br>    <span class="hljs-keyword">return</span> mel_filters<br></code></pre></td></tr></table></figure><ol start="7"><li><p>Calculate the matrix filtered by Mel Filter Bank. If the output of STFT is matrix $A_{T\times N_{fft}}$, and Mel filter bank is matrix $B_{N_{fft}\times N}$. Then the output feature $Feat$ can be defined as:<br>$$<br>Feat &#x3D; A\times B^T<br>$$</p></li><li><p>Normally, we prefer the logarithmic feature. Thus, we perform the following transform<br>$$<br>Feat\gets \log(Feat)<br>$$</p></li><li><p>Calculate log energy.  If the output of STFT is matrix $A_{T\times N_{fft}}$​, the $Energy$​ is a T-dimension vector. The i-th element in the vector can be defined as<br>$$<br>Energy(i)&#x3D;\log(\sum_{k&#x3D;1}^{N_{fft}} A_{i,k})<br>$$</p></li></ol><p>Step 7 and step 8 can be done by following codes</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_feat_and_energy</span>(<span class="hljs-params">stft_matrix, mel_filter_banks, log_energy=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Get feature and energy from the acoustic signal processed by STFT</span><br><span class="hljs-string">    :param log_energy: (boolean, optional) If the value is True, logarithmic energy will be used</span><br><span class="hljs-string">    :param stft_matrix: (ndarray,2d) acoustic signal processed by STFT</span><br><span class="hljs-string">    :param mel_filter_banks: (ndarray,2d) Mel filter bank matrix</span><br><span class="hljs-string">    :return: (tuple) the first element is feature, the second one is energy</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    feat = np.dot(stft_matrix, mel_filter_banks.T)<br>    energy = np.<span class="hljs-built_in">sum</span>(stft_matrix, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(energy)):<br>        <span class="hljs-keyword">if</span> energy[i] == <span class="hljs-number">0</span>:<br>            energy[i] = np.finfo(<span class="hljs-built_in">float</span>).eps<br>    <span class="hljs-keyword">if</span> log_energy:<br>        energy = np.log(energy)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calculate Feat (Apply Mel-filter Bank): done&quot;</span>)<br>    <span class="hljs-keyword">return</span> feat, energy<br></code></pre></td></tr></table></figure><h3 id="6-Discrete-Cosine-Transform-DCT-amp-Log-Energy"><a href="#6-Discrete-Cosine-Transform-DCT-amp-Log-Energy" class="headerlink" title="6. Discrete Cosine Transform (DCT) &amp; Log Energy"></a>6. Discrete Cosine Transform (DCT) &amp; Log Energy</h3><p>The estimated power spectrum contains harmonics of the primary frequency. This makes it harder to estimate the envelop of the spectrum. Besides, bins of STFT are correlated with each other. All of these problems make further analysis hard to be done.</p><p>Cepstral analysis solves the problem above. In source-filter model of speech production, two vital components are investigated. The first component is source characteristics and the second one is the filter characteristics. Source characteristics do not contribute to phone discriminations, while filter characteristics help us to figure out the position of the articulators. And cepstral analysis help us to separate the filter characteristics and source characteristics.</p><p>Cepstrum can be got via applying IDFT to log spectrum. And since log spectrum is real and symmetric. The IDFT can be replaced by DCT, with following formula:<br>$$<br>C_t(j)&#x3D;\sum_{m&#x3D;0}^{M-1}Feat(t,m)\cos\left((m+0.5)\frac{j\pi}{M}\right), j&#x3D;0,1,…,C-1<br>$$<br>where $C$​​ is number of coefficients we want to extract. Normally, $C&#x3D;13$</p><p>After the transform, we can get 13 MFCC features. However, we can find the value of $C_t(0)$ is significantly larger than other 12 MFCC features. This indirectly causes the decrease of recognition rate after we feed these features into our ASR model. To solve this problem, $C_t(0)$ is replaced by the logarithmic energy ($Energy$​)。</p><p>The code shows how to implement DCT</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">audio_dct</span>(<span class="hljs-params">feat, mfcc_nums=MFCC_NUMBERS</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Perform the discrete cosine transformation(DCT) on a feature matrix</span><br><span class="hljs-string">    :param feat: (ndarray,2d) feature matrix</span><br><span class="hljs-string">    :param mfcc_nums: (int) output MFCC numbers</span><br><span class="hljs-string">    :return: (ndarray,2d) DCT-processed feature matrix</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    dct_matrix = np.zeros((feat.shape[<span class="hljs-number">0</span>], mfcc_nums))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(feat.shape[<span class="hljs-number">0</span>]):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(mfcc_nums):<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(feat.shape[<span class="hljs-number">1</span>]):<br>                dct_matrix[i, j] += feat[i, k] * np.cos((k + <span class="hljs-number">0.5</span>) * j * np.pi / feat.shape[<span class="hljs-number">1</span>])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;DCT: done&quot;</span>)<br>    <span class="hljs-built_in">print</span>(dct_matrix.shape)<br>    <span class="hljs-keyword">return</span> dct_matrix<br></code></pre></td></tr></table></figure><p>And the code below shows how to replace $C_t(0)$ with $Energy$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dct_result = audio_dct(log_feat)<br>dct_result[:,<span class="hljs-number">0</span>] = energy<br></code></pre></td></tr></table></figure><p>Finally, the first 13 MFCC features are obtained</p><h3 id="7-Dynamic-Features-Delta-amp-Delta-delta"><a href="#7-Dynamic-Features-Delta-amp-Delta-delta" class="headerlink" title="7. Dynamic Features (Delta &amp; Delta-delta)"></a>7. Dynamic Features (Delta &amp; Delta-delta)</h3><p>In most cases, speech is not constant between frames. Thus, performing transform on cepstral coefficients to enable the coefficients show the changes over time is an excellent idea. To achieve this goal, delta features are appended.</p><p>For coefficient $c_{t,i}$ (frame $t$, feature $i$), we can perform the following transform<br>$$<br>\Delta c_{t,i} &#x3D; \frac{c_{t+1,i}-c_{t-1，i}}{2}<br>$$<br>After obtaining 13 MFCC delta features, we can perform the same transform again to obtain another 13 MFCC delta-delta features.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_delta_feature</span>(<span class="hljs-params">feat, n</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Calculate the dynamic mfcc feature</span><br><span class="hljs-string">    :param feat: (ndarray,2d) feature</span><br><span class="hljs-string">    :param n: (int) this should be 1 according to PPT</span><br><span class="hljs-string">    :return: (ndarray,2d) dynamic feature</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    deno = <span class="hljs-number">2</span> * np.<span class="hljs-built_in">sum</span>([i * i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>)])<br>    feat_padded = np.pad(feat, ((n, n), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)), mode=<span class="hljs-string">&quot;edge&quot;</span>)<br>    d_feat = np.zeros_like(feat)<br>    weight = np.arange(-n, n + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(feat.shape[<span class="hljs-number">0</span>]):<br>        d_feat[i] = np.dot(weight, feat_padded[i: i + <span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>]) / deno<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calculating Dynamic Feature: done&quot;</span>)<br>    <span class="hljs-keyword">return</span> d_feat<br></code></pre></td></tr></table></figure><h3 id="8-Feature-Transformation-Feature-Normalization"><a href="#8-Feature-Transformation-Feature-Normalization" class="headerlink" title="8. Feature Transformation (Feature Normalization)"></a>8. Feature Transformation (Feature Normalization)</h3><p>Finally, we obtain 39-dimension MFCC features. However, the differences between data induce the uncertainty. To eliminate the mismatch between training and test, feature normalization is introduced.</p><p>There are several kinds of normalization, including Cepstral Mean Normalization (CMN), Cepstral Variance Normalization (CVN) and Cepstral Mean and Variance Normalization (CMVN). In this assignment, CMVN is adopted. </p><p>The CMVN formula given in the PPT:<br>$$<br>\hat{y_t}(j)&#x3D;\frac{y_t(j)-\mu(\bold{y}(j))}{\sigma(\bold{y}(j))}<br>$$<br>According to references <sup><code>[1][2]</code> </sup>, the formula can be also written as.<br>$$<br>feature(t,i)&#x3D;\frac{feature(t,i)-\frac{1}{T}\sum_{k&#x3D;0}^{T}feature(k,i)}{\sqrt{\frac{1}{T-1}\sum_{j&#x3D;0}^{T}((feature(t,i)-\frac{1}{T}\sum_{k&#x3D;0}^{T}feature(k,i))^2)}}<br>$$<br>The formula shows each feature is normalized individually.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">feature_concatenate_normalisation</span>(<span class="hljs-params">feature</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Concatenate vectors of features, and perform Cesptral Variance &amp; Mean Normalization (CVMN)</span><br><span class="hljs-string">    on the matrix. The normalization formula coincides with the one given in the PPT</span><br><span class="hljs-string">    To specific the range and details of the normalization, following papers are referenced</span><br><span class="hljs-string">     - Chen C P , Bilmes J , Kirchhoff K . Low-Resource Noise-Robust Feature Post-Processing On Aurora 2.0. 2002.</span><br><span class="hljs-string">     - Chapaneri S V , Chapaneri S V . Spoken Digits Recognition using Weighted MFCC and Improved Features for Dynamic</span><br><span class="hljs-string">       Time Warping[J]. International Journal of Computer Applications, 2012, 40(3):6-12.</span><br><span class="hljs-string">    :param feature: (ndarray,tuple,list) MFCC feature or the delta feature</span><br><span class="hljs-string">    :return: (ndarray) Concatenated matrix of MFCC feature. Each row contains a frame, and each column</span><br><span class="hljs-string">     contains a CMVN-normalized feature</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># First, concatenate features to generate the feature matrix</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(feature, <span class="hljs-built_in">tuple</span>) <span class="hljs-keyword">or</span> <span class="hljs-built_in">isinstance</span>(feature, <span class="hljs-built_in">list</span>):<br>        feature_f = np.array(feature)<br>    <span class="hljs-keyword">else</span>:<br>        feature_f = feature<br>    feature_shape = feature_f.shape<br>    numbers = feature_shape[<span class="hljs-number">0</span>]<br>    concat_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numbers):<br>        concat_list.append(feature_f[i])<br>    concat_tuple = <span class="hljs-built_in">tuple</span>(concat_list)<br>    concat_matrix = np.concatenate(concat_tuple, axis=<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># Then, perform Cesptral Variance &amp; Mean Normalization (CVMN) on each feature.</span><br>    feature_count = concat_matrix.shape[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(feature_count):<br>        feature_mean = np.mean(concat_matrix[:, i])<br>        feature_std_var = np.std(concat_matrix[:, i], ddof=<span class="hljs-number">1</span>)<br>        concat_matrix[:, i] = (concat_matrix[:, i] - feature_mean) / feature_std_var<br>    <span class="hljs-keyword">return</span> concat_matrix<br></code></pre></td></tr></table></figure><p>Finally, the 39-dimensional feature of “Ni Hao” is obtained.</p><h3 id="Bibliography"><a href="#Bibliography" class="headerlink" title="Bibliography"></a>Bibliography</h3><blockquote><p>[1] Chen C P , Bilmes J , Kirchhoff K . Low-Resource Noise-Robust Feature Post-Processing On Aurora 2.0. 2002.</p><p>[2] Chapaneri S V , Chapaneri S V . Spoken Digits Recognition using Weighted MFCC and Improved Features for Dynamic Time Warping[J]. International Journal of Computer Applications, 2012, 40(3):6-12.</p></blockquote><h3 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h3><h4 id="A-1-Main-Procedure"><a href="#A-1-Main-Procedure" class="headerlink" title="A.1  Main Procedure"></a>A.1  Main Procedure</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Read audio &amp; Pre-emphasis</span><br>sampling_freq, audio = audio_read(<span class="hljs-string">&quot;hello_1950641.wav&quot;</span>, <span class="hljs-literal">True</span>)<br>audio, audio_original = audio_preemphasis(audio)<br>audio_sequence_visualize(audio_original, <span class="hljs-string">&quot;Original Signal&quot;</span>, <span class="hljs-number">0</span>)<br>audio_sequence_visualize(audio, <span class="hljs-string">&quot;Pre-emphasized Signal&quot;</span>, <span class="hljs-number">1</span>)<br>audio_frequency_visualize(audio_original,sampling_freq,<span class="hljs-string">&quot;Frequency Components (Original)&quot;</span>)<br>audio_frequency_visualize(audio,sampling_freq,<span class="hljs-string">&quot;Frequency Components (Pre-emphasized)&quot;</span>)<br><br><span class="hljs-comment"># Windowing (Padding Zero)</span><br>frame, frame_count, frame_size = audio_windowing(audio, sampling_freq)<br><br><span class="hljs-comment"># Short-time Fourier Transformation (STFT)</span><br>frame_stft, fft_bins = audio_fft(frame, frame_count)<br>audio_spectrogram_visualize(frame_stft, fft_bins // <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, sampling_freq)<br><br><span class="hljs-comment"># Get Mel Filter Banks</span><br>mel_filter_banks = get_mel_filter_banks(sampling_freq, fft_bins, MEL_FILTERS, <span class="hljs-number">300</span>, sampling_freq // <span class="hljs-number">2</span>)<br>visualize_mel_filter_bank(mel_filter_banks)<br><br><span class="hljs-comment"># Apply Mel Filter &amp; Log</span><br>feat, energy = get_feat_and_energy(frame_stft, mel_filter_banks)<br>log_feat = np.log(feat)<br>feat_spectrogram_visualize(log_feat)<br><br><span class="hljs-comment"># Apply Discrete Cosine Transformation (DCT)</span><br>dct_result = audio_dct(log_feat)<br>dct_result[:,<span class="hljs-number">0</span>] = energy<br>cepstrum_spectrogram_visualize(dct_result, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;MFCC Result&quot;</span>)<br><br><span class="hljs-comment"># Calculate Dynamic Features</span><br>feat_order_1 = calculate_delta_feature(dct_result, <span class="hljs-number">1</span>)<br>feat_order_2 = calculate_delta_feature(feat_order_1, <span class="hljs-number">1</span>)<br>feature_spectrogram_visualize(feat_order_1, <span class="hljs-number">6</span>, <span class="hljs-string">&quot;Dynamic Feature (Order 1)&quot;</span>)<br>feature_spectrogram_visualize(feat_order_2, <span class="hljs-number">7</span>, <span class="hljs-string">&quot;Dynamic Feature (Order 2)&quot;</span>)<br><br><span class="hljs-comment"># Feature Normalization</span><br>feature_vector = feature_concatenate_normalisation((dct_result, feat_order_1, feat_order_2))<br>feature_spectrogram_visualize(feature_vector, <span class="hljs-number">8</span>, <span class="hljs-string">&quot;Normalized Feature Matrix&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="A-2-Audio-Spectrogram-Visualization"><a href="#A-2-Audio-Spectrogram-Visualization" class="headerlink" title="A.2 Audio Spectrogram Visualization"></a>A.2 Audio Spectrogram Visualization</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">audio_spectrogram_visualize</span>(<span class="hljs-params">frame_window_transformed, frame_size, sampling_freq, subplot_id=<span class="hljs-number">2</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Visualize the spectrogram</span><br><span class="hljs-string">    :param subplot_id: (int) subplot location to be shown</span><br><span class="hljs-string">    :param frame_window_transformed: (ndarray,2d) DFT-transformed matrix of audio data</span><br><span class="hljs-string">    :param frame_size: (int) size of windowing frames</span><br><span class="hljs-string">    :param sampling_freq: (int) sampling frequency of the original audio</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># Preparing for the coordinates</span><br>    frame_window_trans_crop = frame_window_transformed[:, :frame_window_transformed.shape[<span class="hljs-number">1</span>]]<br>    yt = np.linspace(<span class="hljs-number">0</span>, frame_size, <span class="hljs-number">10</span>)<br>    xt = np.linspace(<span class="hljs-number">0</span>, frame_window_transformed.shape[<span class="hljs-number">0</span>], <span class="hljs-number">10</span>)<br>    s = sampling_freq // <span class="hljs-number">2</span> / frame_size * yt<br>    r = FRAME_SHIFT_MS * np.linspace(<span class="hljs-number">0</span>, frame_window_transformed.shape[<span class="hljs-number">0</span>], <span class="hljs-number">10</span>)<br>    r = r.astype(<span class="hljs-string">&quot;int&quot;</span>)<br>    s = s.astype(<span class="hljs-string">&quot;int&quot;</span>)<br>    <span class="hljs-comment"># The following conversion transforms the unit to decibel</span><br>    test = np.log10(frame_window_trans_crop.T+np.finfo(<span class="hljs-string">&quot;float&quot;</span>).eps) * <span class="hljs-number">10</span><br>    visualize_subplot(subplot_id)<br>    plt.pcolormesh(test)<br>    plt.yticks(yt, s)<br>    plt.ylabel(<span class="hljs-string">&quot;Frequency (Hz)&quot;</span>)<br>    plt.xticks(xt, r)<br>    plt.xlabel(<span class="hljs-string">&quot;Time (ms)&quot;</span>)<br>    cbar = plt.colorbar()<br>    cbar.ax.set_ylabel(<span class="hljs-string">&quot;Decibel (dB)&quot;</span>)<br>    plt.title(<span class="hljs-string">&quot;Acoustic Spectrogram&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="A-3-Frequency-Component-Visualization"><a href="#A-3-Frequency-Component-Visualization" class="headerlink" title="A.3 Frequency Component Visualization"></a>A.3 Frequency Component Visualization</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">audio_frequency_visualize</span>(<span class="hljs-params">audio_sequence, sampling_rate,title=<span class="hljs-string">&quot;Frequency Components of Audio Sequence&quot;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Visualize frequency components of an audio segment</span><br><span class="hljs-string">    :param audio_sequence: (ndarray) audio segment</span><br><span class="hljs-string">    :param sampling_rate: (int) sampling rate</span><br><span class="hljs-string">    :param title: (str) title to be shown</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    freq_amp = np.<span class="hljs-built_in">abs</span>(np.fft.rfft(audio_sequence,<span class="hljs-number">512</span>)) ** <span class="hljs-number">2</span><br>    fftbins=<span class="hljs-number">512</span><br>    st = [sampling_rate // <span class="hljs-number">2</span> / fftbins * i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(freq_amp.shape[<span class="hljs-number">0</span>])]<br>    visualize_subplot(<span class="hljs-number">0</span>)<br>    plt.xlabel(<span class="hljs-string">&quot;Frequency (Hz)&quot;</span>)<br>    plt.ylabel(<span class="hljs-string">&quot;Accumulated Energy (dB)&quot;</span>)<br>    plt.title(title)<br>    freq_amp = np.log10(freq_amp+np.finfo(<span class="hljs-string">&quot;float&quot;</span>).eps)*<span class="hljs-number">10</span><br>    plt.plot(st, freq_amp)<br></code></pre></td></tr></table></figure><h4 id="A-4-Mel-filter-Bank-Visualization"><a href="#A-4-Mel-filter-Bank-Visualization" class="headerlink" title="A.4 Mel-filter Bank Visualization"></a>A.4 Mel-filter Bank Visualization</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">visualize_mel_filter_bank</span>(<span class="hljs-params">mel_filter_bank</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Visualize Mel filter bank via plot graph</span><br><span class="hljs-string">    :param mel_filter_bank:(ndarray,2d) Mel filter bank matrix</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    fft_bins = mel_filter_bank.shape[<span class="hljs-number">1</span>]<br>    mel_filters = mel_filter_bank.shape[<span class="hljs-number">0</span>]<br>    x_axis = np.array([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(fft_bins)])<br>    visualize_subplot(<span class="hljs-number">3</span>)<br>    plt.title(<span class="hljs-string">&quot;Mel Filter Banks&quot;</span>)<br>    plt.xlabel(<span class="hljs-string">&quot;FFT bin&quot;</span>)<br>    plt.ylabel(<span class="hljs-string">&quot;Scale Factor&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(mel_filters):<br>        plt.plot(x_axis, mel_filter_bank[i, :])<br></code></pre></td></tr></table></figure><h4 id="A-5-Feature-Visualization"><a href="#A-5-Feature-Visualization" class="headerlink" title="A.5 Feature Visualization"></a>A.5 Feature Visualization</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">feat_spectrogram_visualize</span>(<span class="hljs-params">feat</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Visualize feature via color map graph</span><br><span class="hljs-string">    :param feat: (ndarray,2d) feature matrix</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    feat_crop = feat[:, :feat.shape[<span class="hljs-number">1</span>]]<br>    xt = np.linspace(<span class="hljs-number">0</span>, feat.shape[<span class="hljs-number">0</span>], <span class="hljs-number">10</span>)<br>    r = FRAME_SHIFT_MS * np.linspace(<span class="hljs-number">0</span>, feat.shape[<span class="hljs-number">0</span>], <span class="hljs-number">10</span>)<br>    r = r.astype(<span class="hljs-string">&quot;int&quot;</span>)<br>    test = feat_crop.T<br>    visualize_subplot(<span class="hljs-number">4</span>)<br>    plt.pcolormesh(test)<br>    plt.ylabel(<span class="hljs-string">&quot;Mel-Filter Results&quot;</span>)<br>    plt.xticks(xt, r)<br>    plt.xlabel(<span class="hljs-string">&quot;Time (ms)&quot;</span>)<br>    plt.colorbar()<br>    plt.title(<span class="hljs-string">&quot;Feat Spectrogram&quot;</span>)<br>    <br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cepstrum_spectrogram_visualize</span>(<span class="hljs-params">feat, subplot_id=<span class="hljs-number">5</span>, title=<span class="hljs-string">&quot;Cepstrum Color Map&quot;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Visualize cepstrum via color map graph</span><br><span class="hljs-string">    :param title: (str) title to be shown</span><br><span class="hljs-string">    :param subplot_id: (int) subplot location</span><br><span class="hljs-string">    :param feat:(ndarray,2d) cepstrum matrix</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    feat_crop = feat[:, :feat.shape[<span class="hljs-number">1</span>]]<br>    xt = np.linspace(<span class="hljs-number">0</span>, feat.shape[<span class="hljs-number">0</span>], <span class="hljs-number">5</span>)<br>    r = FRAME_SHIFT_MS * np.linspace(<span class="hljs-number">0</span>, feat.shape[<span class="hljs-number">0</span>], <span class="hljs-number">5</span>)<br>    r = r.astype(<span class="hljs-string">&quot;int&quot;</span>)<br>    test = feat_crop.T<br>    visualize_subplot(subplot_id)<br>    plt.pcolormesh(test)<br>    plt.ylabel(<span class="hljs-string">&quot;Cepstrum&quot;</span>)<br>    plt.xticks(xt, r)<br>    plt.xlabel(<span class="hljs-string">&quot;Time (ms)&quot;</span>)<br>    plt.colorbar()<br>    plt.title(title)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">feature_spectrogram_visualize</span>(<span class="hljs-params">feat, subplot_id=<span class="hljs-number">5</span>, title=<span class="hljs-string">&quot;Feature Map&quot;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Visualize cepstrum via color map graph</span><br><span class="hljs-string">    :param title: (str) title to be shown</span><br><span class="hljs-string">    :param subplot_id: (int) subplot location</span><br><span class="hljs-string">    :param feat:(ndarray,2d) cepstrum matrix</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    feat_crop = feat[:, :feat.shape[<span class="hljs-number">1</span>]]<br>    xt = np.linspace(<span class="hljs-number">0</span>, feat.shape[<span class="hljs-number">0</span>], <span class="hljs-number">5</span>)<br>    r = FRAME_SHIFT_MS * np.linspace(<span class="hljs-number">0</span>, feat.shape[<span class="hljs-number">0</span>], <span class="hljs-number">5</span>)<br>    r = r.astype(<span class="hljs-string">&quot;int&quot;</span>)<br>    test = feat_crop.T<br>    visualize_subplot(subplot_id)<br>    plt.pcolormesh(test)<br>    plt.ylabel(<span class="hljs-string">&quot;Feature&quot;</span>)<br>    plt.xticks(xt, r)<br>    plt.xlabel(<span class="hljs-string">&quot;Time (ms)&quot;</span>)<br>    plt.colorbar()<br>    plt.title(title)<br><br></code></pre></td></tr></table></figure><h4 id="A-6-Audio-Waveform-Graph-Visualization"><a href="#A-6-Audio-Waveform-Graph-Visualization" class="headerlink" title="A.6 Audio Waveform Graph Visualization"></a>A.6 Audio Waveform Graph Visualization</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">audio_sequence_visualize</span>(<span class="hljs-params">audio_sequence, title, subplot_id</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Visualize the audio sequence in a plot diagram</span><br><span class="hljs-string">    :param subplot_id: (int) location of subplot</span><br><span class="hljs-string">    :param audio_sequence: (ndarray,1d) audio sequence read</span><br><span class="hljs-string">    :param title: (str) title to be shown in the graph</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    visualize_subplot(subplot_id)<br>    x_axis = np.array([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(audio_sequence))])<br>    plt.plot(x_axis, audio_sequence)<br>    plt.xlabel(<span class="hljs-string">&quot;Sample Points&quot;</span>)<br>    plt.ylabel(<span class="hljs-string">&quot;Amplitude&quot;</span>)<br>    plt.title(title)<br></code></pre></td></tr></table></figure><h4 id="A-7-Running-Environment"><a href="#A-7-Running-Environment" class="headerlink" title="A.7 Running Environment"></a>A.7 Running Environment</h4><p>Recommended running environment:</p><ul><li>Python 3.9</li><li>NumPy 1.19.5</li><li>SciPy 1.7.0</li><li>Matplotlib 3.4.2</li><li>Jupyter 1.0.0 (Jupyter Notebook)</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>(CS)Machine Learning</tag>
      
      <tag>(MI)Course</tag>
      
      <tag>(CS)Speech Recognition</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
